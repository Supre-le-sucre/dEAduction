/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/venv/bin/python "/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/pydevconsole.py" --mode=client --port=52179
import sys; print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(['/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction'])
PyDev console: starting.
Python 3.7.0 (default, Jul 23 2018, 20:24:19) 
[Clang 9.0.0 (clang-900.0.39.2)] on darwin
>>> import os
... os.environ['DEADUCTION_USE_COLOR'] = '1'
... runfile('/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/src/deaduction/dui/__main__.py', wdir='/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/')
... 
INFO      deaduction.dui.launcher: Selected course: /Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/tests/lean_files/courses/exercises_theorie_des_ensembles.lean
INFO      Course initialisation: Parsing file /Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/tests/lean_files/courses/exercises_theorie_des_ensembles.lean
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'CourseTitle': ' Théorie des Ensembles', 'Author': ' Camille Nous', 'Date': ' 08/2020', 'University': ' Some French University', 'CourseId': ' 1MA999'}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': ' Théorie des ensembles'}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': ' Egalité de deux ensembles'}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': ' Double inclusion'}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': ' Intersection de deux ensembles'}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': " Intersection d'une famille d'ensembles quelconque"}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': ' Union de deux ensembles'}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': " Union d'une famille d'ensembles quelconque"}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': " Intersection d'une union", 'Description': " L'intersection est distributive par rapport à l'union", 'Tools->Logic': ' $ALL -negate', 'Tools->ProofTechniques': ' $ALL -contradiction', 'Tools->Definitions': ' $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles', 'Tools->Theorems': ' double_inclusion', 'ExpectedVarsNumber': ' X=3, A=1, B=1'}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': " L'union est distributive par rapport à l'intersection"}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': ' Complémentaire'}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': ' Complémentaire du complémentaire', 'Description': ' Tout ensemble est égal au complémentaire de son complémentaire'}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': " Complémentaire d'union I", 'Description': " Le complémentaire de l'union de deux ensembles égale l'intersection des complémentaires"}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': " Complémentaire d'union II", 'Description': " Le complémentaire d'une réunion quelconque égale l'intersection des complémentaires"}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': ' Le passage au complémentaire renverse les inclusions', 'Description': ' Si A est inclus dans B, alors le complémentaire de A contient le complémentaire de B'}}
DEBUG     deaduction.pylib.coursedata.parser_course: got metadata {'metadata': {'PrettyName': ' injections et surjections'}}
DEBUG     Course initialisation: course history: [('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'theorie_des_ensembles', 'pretty_name': ' Théorie des ensembles'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.inclusion', 'lean_statement': '(A B : set X) : A ⊆ B ↔ ∀ {{x:X}}, x ∈ A → x ∈ B ', 'PrettyName': 'Inclusion'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': ' Egalité de deux ensembles', 'lean_name': 'definition.egalite_deux_ensembles', 'lean_statement': "{A A' : set X} : (A = A') ↔ ( ∀ x, x ∈ A ↔ x ∈ A' ) "}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('theorem', {'PrettyName': ' Double inclusion', 'lean_name': 'theorem.double_inclusion', 'lean_statement': "{A A' : set X} : (A ⊆ A' ∧ A' ⊆ A) → A = A' "}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'unions_et_intersections', 'pretty_name': 'Unions et intersections'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': ' Intersection de deux ensembles', 'lean_name': 'definition.intersection_deux_ensembles', 'lean_statement': '(A B : set X) (x : X) :  x ∈ A ∩ B ↔ ( x ∈ A ∧ x ∈ B) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': " Intersection d'une famille d'ensembles quelconque", 'lean_name': 'definition.intersection_quelconque_ensembles', 'lean_statement': '(I : Type) (O : I → set X)  (x : X) : (x ∈ set.Inter O) ↔ (∀ i:I, x ∈ O i) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': ' Union de deux ensembles', 'lean_name': 'definition.union_deux_ensembles', 'lean_statement': '(A : set X) (B : set X) (x : X) :  x ∈ A ∪ B ↔ ( x ∈ A ∨ x ∈ B) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': " Union d'une famille d'ensembles quelconque", 'lean_name': 'definition.union_quelconque_ensembles', 'lean_statement': '(I : Type) (O : I → set X)  (x : X) : (x ∈ set.Union O) ↔ (∃ i:I, x ∈ O i) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': " Intersection d'une union", 'Description': " L'intersection est distributive par rapport à l'union", 'Tools->Logic': ' $ALL -negate', 'Tools->ProofTechniques': ' $ALL -contradiction', 'Tools->Definitions': ' $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles', 'Tools->Theorems': ' double_inclusion', 'ExpectedVarsNumber': ' X=3, A=1, B=1', 'lean_name': 'exercise.union_distributive_inter', 'lean_statement': ': A ∩ (B ∪ C)  = (A ∩ B) ∪ (A ∩ C) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': " L'union est distributive par rapport à l'intersection", 'lean_name': 'exercise.inter_distributive_union', 'lean_statement': ': A ∪ (B ∩ C)  = (A ∪ B) ∩ (A ∪ C) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'complementaire', 'pretty_name': 'Complementaire'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': ' Complémentaire', 'lean_name': 'definition.complement', 'lean_statement': '{A : set X} {x : X} : x ∈ set.compl A ↔ x ∉ A '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': ' Complémentaire du complémentaire', 'Description': ' Tout ensemble est égal au complémentaire de son complémentaire', 'lean_name': 'exercise.complement_complement', 'lean_statement': ': (set.compl (set.compl A)) =A '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': " Complémentaire d'union I", 'Description': " Le complémentaire de l'union de deux ensembles égale l'intersection des complémentaires", 'lean_name': 'exercise.complement_union_deux', 'lean_statement': ': set.compl (A ∪ B) = (set.compl A) ∩ (set.compl B) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': " Complémentaire d'union II", 'Description': " Le complémentaire d'une réunion quelconque égale l'intersection des complémentaires", 'lean_name': 'exercise.complement_union_quelconque', 'lean_statement': '(H : ∀ i, F i = set.compl (E i)) : set.compl (set.Union E) = set.Inter F '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': ' Le passage au complémentaire renverse les inclusions', 'Description': ' Si A est inclus dans B, alors le complémentaire de A contient le complémentaire de B', 'lean_name': 'exercise.inclusion_complement', 'lean_statement': ':\nA ⊆ B → set.compl B ⊆ set.compl A\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'applications', 'pretty_name': 'Applications'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.image_directe', 'lean_statement': "(y : Y) : y ∈ f '' A ↔ ∃ x : X, x ∈ A ∧  f x = y ", 'PrettyName': 'Image directe'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.image_reciproque', 'lean_statement': "(x:X) : x ∈ f  ⁻¹' B ↔ f(x) ∈ B ", 'PrettyName': 'Image reciproque'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'lean_name': 'exercise.image_de_reciproque', 'lean_statement': ": f '' (f ⁻¹' B)  ⊆ B ", 'PrettyName': 'Image de reciproque'}), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'lean_name': 'exercise.image_reciproque_inter', 'lean_statement': ":  f ⁻¹'  (B∩B') = f ⁻¹'  (B) ∩ f ⁻¹'  (B') ", 'PrettyName': 'Image reciproque inter'}), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'lean_name': 'exercise.image_reciproque_union', 'lean_statement': ": f ⁻¹' (B ∪ B') = f ⁻¹' B ∪ f ⁻¹' B'\n", 'PrettyName': 'Image reciproque union'}), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'lean_name': 'exercise.image_reciproque_inter_quelconque', 'lean_statement': "(H : ∀ i:I,  (E i = f ⁻¹' (F i))) :\n(f ⁻¹'  (set.Inter F)) = set.Inter E\n", 'PrettyName': 'Image reciproque inter quelconque'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'lean_name': 'exercise.image_inter_inclus_inter_images', 'lean_statement': ":\nf '' (A∩A') ⊆ f '' (A) ∩ f '' (A')\n", 'PrettyName': 'Image inter inclus inter images'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'lean_name': 'exercise.reciproque_complementaire', 'lean_statement': ":\nf ⁻¹' (set.compl B) = set.compl (f ⁻¹' B)\n", 'PrettyName': 'Reciproque complementaire'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'injections_surjections', 'pretty_name': ' injections et surjections'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.injectivite', 'lean_statement': ':\ninjective f ↔ ∀ x y : X, (f x = f y → x = y)\n', 'PrettyName': 'Injectivite'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.surjectivite', 'lean_statement': ':\nsurjective f ↔ ∀ y : Y, ∃ x : X, f x = y\n', 'PrettyName': 'Surjectivite'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.composition', 'lean_statement': ':\nh = composition g f ↔ ∀ x : X, h x = g (f x)\n', 'PrettyName': 'Composition'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'lean_name': 'exercise.composition_injections', 'lean_statement': '(H0 : h = composition g f)\n(H1 : injective f) (H2 : injective g) :\ninjective h\n', 'PrettyName': 'Composition injections'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'lean_name': 'exercise.composition_surjections', 'lean_statement': '(H0 : h = composition g f)\n(H1 : surjective f) (H2 : surjective g) :\nsurjective h\n', 'PrettyName': 'Composition surjections'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'lean_name': 'exercise.injective_si_coompo_injective', 'lean_statement': '(H0 : h = composition g f)\n(H1 : injective h) :\ninjective f\n', 'PrettyName': 'Injective si coompo injective'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'lean_name': 'exercise.surjective_si_coompo_surjective', 'lean_statement': '(H0 : h = composition g f)\n(H1 : surjective h) :\nsurjective g\n', 'PrettyName': 'Surjective si coompo surjective'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', None)]
DEBUG     Course initialisation: Parsing line 2
DEBUG     Course initialisation: Parsing line 3
DEBUG     Course initialisation: Parsing line 4
DEBUG     Course initialisation: Parsing line 5
DEBUG     Course initialisation: Parsing line 6
DEBUG     Course initialisation: Parsing line 7
DEBUG     Course initialisation: Parsing line 8
DEBUG     Course initialisation: Parsing line 9
DEBUG     Course initialisation: Parsing line 10
DEBUG     Course initialisation: Parsing line 11
DEBUG     Course initialisation: Parsing line 12
DEBUG     Course initialisation: Parsing line 13
DEBUG     Course initialisation: Parsing line 14
DEBUG     Course initialisation: Parsing line 15
DEBUG     Course initialisation: Parsing line 16
DEBUG     Course initialisation: Parsing line 17
DEBUG     Course initialisation: Parsing line 18
DEBUG     Course initialisation: Parsing line 19
DEBUG     Course initialisation: Parsing line 20
DEBUG     Course initialisation: Parsing line 21
DEBUG     Course initialisation: Parsing line 22
DEBUG     Course initialisation: Parsing line 23
DEBUG     Course initialisation: Parsing line 24
DEBUG     Course initialisation: Parsing line 25
DEBUG     Course initialisation: Parsing line 26
DEBUG     Course initialisation: Parsing line 27
DEBUG     Course initialisation: Parsing line 28
DEBUG     Course initialisation: Parsing line 29
DEBUG     Course initialisation: Parsing line 30
DEBUG     Course initialisation: namespace theorie_des_ensembles
DEBUG     Course initialisation: Parsing line 31
DEBUG     Course initialisation: Parsing line 32
DEBUG     Course initialisation: Parsing line 33
DEBUG     Course initialisation: Parsing line 34
DEBUG     Course initialisation: Parsing line 35
DEBUG     Course initialisation: Parsing line 36
DEBUG     Course initialisation: Parsing line 37
DEBUG     Course initialisation: Parsing line 38
DEBUG     Course initialisation: Parsing line 39
DEBUG     Course initialisation: Parsing line 40
DEBUG     Course initialisation: Parsing line 41
DEBUG     Course initialisation: Parsing line 42
INFO      Course initialisation: creating definition from data {'lean_name': 'theorie_des_ensembles.definition.inclusion', 'lean_statement': '(A B : set X) : A ⊆ B ↔ ∀ {{x:X}}, x ∈ A → x ∈ B ', 'PrettyName': 'Inclusion', 'lean_line': 42, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 43
DEBUG     Course initialisation: Parsing line 44
DEBUG     Course initialisation: Parsing line 45
INFO      Course initialisation: creating definition from data {'PrettyName': ' Egalité de deux ensembles', 'lean_name': 'theorie_des_ensembles.definition.egalite_deux_ensembles', 'lean_statement': "{A A' : set X} : (A = A') ↔ ( ∀ x, x ∈ A ↔ x ∈ A' ) ", 'lean_line': 45, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 46
DEBUG     Course initialisation: Parsing line 47
DEBUG     Course initialisation: Parsing line 48
DEBUG     Course initialisation: Parsing line 49
DEBUG     Course initialisation: Parsing line 50
DEBUG     Course initialisation: Parsing line 51
DEBUG     Course initialisation: Parsing line 52
INFO      Course initialisation: creating theorem from data {'PrettyName': ' Double inclusion', 'lean_name': 'theorie_des_ensembles.theorem.double_inclusion', 'lean_statement': "{A A' : set X} : (A ⊆ A' ∧ A' ⊆ A) → A = A' ", 'lean_line': 52, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 53
DEBUG     Course initialisation: Parsing line 54
DEBUG     Course initialisation: Parsing line 55
DEBUG     Course initialisation: Parsing line 56
DEBUG     Course initialisation: Parsing line 57
DEBUG     Course initialisation: Parsing line 58
DEBUG     Course initialisation: Parsing line 59
DEBUG     Course initialisation: Parsing line 60
DEBUG     Course initialisation: Parsing line 61
DEBUG     Course initialisation: Parsing line 62
DEBUG     Course initialisation: Parsing line 63
DEBUG     Course initialisation: Parsing line 64
DEBUG     Course initialisation: Parsing line 65
DEBUG     Course initialisation: Parsing line 66
DEBUG     Course initialisation: Parsing line 67
DEBUG     Course initialisation: Parsing line 68
DEBUG     Course initialisation: Parsing line 69
DEBUG     Course initialisation: namespace theorie_des_ensembles.unions_et_intersections
DEBUG     Course initialisation: Parsing line 70
DEBUG     Course initialisation: Parsing line 71
DEBUG     Course initialisation: Parsing line 72
DEBUG     Course initialisation: Parsing line 73
DEBUG     Course initialisation: Parsing line 74
DEBUG     Course initialisation: Parsing line 75
DEBUG     Course initialisation: Parsing line 76
INFO      Course initialisation: creating definition from data {'PrettyName': ' Intersection de deux ensembles', 'lean_name': 'theorie_des_ensembles.unions_et_intersections.definition.intersection_deux_ensembles', 'lean_statement': '(A B : set X) (x : X) :  x ∈ A ∩ B ↔ ( x ∈ A ∧ x ∈ B) ', 'lean_line': 76, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 77
DEBUG     Course initialisation: Parsing line 78
DEBUG     Course initialisation: Parsing line 79
DEBUG     Course initialisation: Parsing line 80
DEBUG     Course initialisation: Parsing line 81
DEBUG     Course initialisation: Parsing line 82
DEBUG     Course initialisation: Parsing line 83
INFO      Course initialisation: creating definition from data {'PrettyName': " Intersection d'une famille d'ensembles quelconque", 'lean_name': 'theorie_des_ensembles.unions_et_intersections.definition.intersection_quelconque_ensembles', 'lean_statement': '(I : Type) (O : I → set X)  (x : X) : (x ∈ set.Inter O) ↔ (∀ i:I, x ∈ O i) ', 'lean_line': 83, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 84
DEBUG     Course initialisation: Parsing line 85
DEBUG     Course initialisation: Parsing line 86
DEBUG     Course initialisation: Parsing line 87
DEBUG     Course initialisation: Parsing line 88
DEBUG     Course initialisation: Parsing line 89
DEBUG     Course initialisation: Parsing line 90
INFO      Course initialisation: creating definition from data {'PrettyName': ' Union de deux ensembles', 'lean_name': 'theorie_des_ensembles.unions_et_intersections.definition.union_deux_ensembles', 'lean_statement': '(A : set X) (B : set X) (x : X) :  x ∈ A ∪ B ↔ ( x ∈ A ∨ x ∈ B) ', 'lean_line': 90, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 91
DEBUG     Course initialisation: Parsing line 92
DEBUG     Course initialisation: Parsing line 93
DEBUG     Course initialisation: Parsing line 94
DEBUG     Course initialisation: Parsing line 95
DEBUG     Course initialisation: Parsing line 96
DEBUG     Course initialisation: Parsing line 97
INFO      Course initialisation: creating definition from data {'PrettyName': " Union d'une famille d'ensembles quelconque", 'lean_name': 'theorie_des_ensembles.unions_et_intersections.definition.union_quelconque_ensembles', 'lean_statement': '(I : Type) (O : I → set X)  (x : X) : (x ∈ set.Union O) ↔ (∃ i:I, x ∈ O i) ', 'lean_line': 97, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 98
DEBUG     Course initialisation: Parsing line 99
DEBUG     Course initialisation: Parsing line 100
DEBUG     Course initialisation: Parsing line 101
DEBUG     Course initialisation: Parsing line 102
DEBUG     Course initialisation: Parsing line 103
DEBUG     Course initialisation: Parsing line 104
DEBUG     Course initialisation: Parsing line 105
DEBUG     Course initialisation: Parsing line 106
DEBUG     Course initialisation: Parsing line 107
DEBUG     Course initialisation: Parsing line 108
INFO      Course initialisation: creating exercise from data {'PrettyName': " Intersection d'une union", 'Description': " L'intersection est distributive par rapport à l'union", 'Tools->Logic': ' $ALL -negate', 'Tools->ProofTechniques': ' $ALL -contradiction', 'Tools->Definitions': ' $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles', 'Tools->Theorems': ' double_inclusion', 'ExpectedVarsNumber': ' X=3, A=1, B=1', 'lean_name': 'theorie_des_ensembles.unions_et_intersections.exercise.union_distributive_inter', 'lean_statement': ': A ∩ (B ∪ C)  = (A ∩ B) ∪ (A ∩ C) ', 'lean_line': 108, 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Magic': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions,  $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles
DEBUG     Course initialisation: processing data in Tools->Theorems,  double_inclusion
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic,  $ALL -negate
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution', '-negate']
DEBUG     Course initialisation: list 3: ['and', 'or', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques,  $ALL -contradiction
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption', '-contradiction']
WARNING   Course initialisation: Cannot remove item contradiction from list
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 109
DEBUG     Course initialisation: Parsing line 110
DEBUG     Course initialisation: Parsing line 111
DEBUG     Course initialisation: Parsing line 112
DEBUG     Course initialisation: Parsing line 113
DEBUG     Course initialisation: Parsing line 114
DEBUG     Course initialisation: Parsing line 115
DEBUG     Course initialisation: Parsing line 116
DEBUG     Course initialisation: Parsing line 117
DEBUG     Course initialisation: Parsing line 118
DEBUG     Course initialisation: Parsing line 119
DEBUG     Course initialisation: Parsing line 120
DEBUG     Course initialisation: Parsing line 121
DEBUG     Course initialisation: Parsing line 122
DEBUG     Course initialisation: Parsing line 123
DEBUG     Course initialisation: Parsing line 124
DEBUG     Course initialisation: Parsing line 125
DEBUG     Course initialisation: Parsing line 126
DEBUG     Course initialisation: Parsing line 127
DEBUG     Course initialisation: Parsing line 128
DEBUG     Course initialisation: Parsing line 129
DEBUG     Course initialisation: Parsing line 130
INFO      Course initialisation: creating exercise from data {'PrettyName': " L'union est distributive par rapport à l'intersection", 'lean_name': 'theorie_des_ensembles.unions_et_intersections.exercise.inter_distributive_union', 'lean_statement': ': A ∪ (B ∩ C)  = (A ∪ B) ∩ (A ∪ C) ', 'lean_line': 130, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 131
DEBUG     Course initialisation: Parsing line 132
DEBUG     Course initialisation: Parsing line 133
DEBUG     Course initialisation: Parsing line 134
DEBUG     Course initialisation: Parsing line 135
DEBUG     Course initialisation: Parsing line 136
DEBUG     Course initialisation: Parsing line 137
DEBUG     Course initialisation: Parsing line 138
DEBUG     Course initialisation: Parsing line 139
DEBUG     Course initialisation: closing namespace
DEBUG     Course initialisation: Parsing line 140
DEBUG     Course initialisation: Parsing line 141
DEBUG     Course initialisation: Parsing line 142
DEBUG     Course initialisation: Parsing line 143
DEBUG     Course initialisation: Parsing line 144
DEBUG     Course initialisation: Parsing line 145
DEBUG     Course initialisation: Parsing line 146
DEBUG     Course initialisation: Parsing line 147
DEBUG     Course initialisation: Parsing line 148
DEBUG     Course initialisation: Parsing line 149
DEBUG     Course initialisation: namespace theorie_des_ensembles.complementaire
DEBUG     Course initialisation: Parsing line 150
DEBUG     Course initialisation: Parsing line 151
DEBUG     Course initialisation: Parsing line 152
DEBUG     Course initialisation: Parsing line 153
DEBUG     Course initialisation: Parsing line 154
DEBUG     Course initialisation: Parsing line 155
DEBUG     Course initialisation: Parsing line 156
DEBUG     Course initialisation: Parsing line 157
DEBUG     Course initialisation: Parsing line 158
INFO      Course initialisation: creating definition from data {'PrettyName': ' Complémentaire', 'lean_name': 'theorie_des_ensembles.complementaire.definition.complement', 'lean_statement': '{A : set X} {x : X} : x ∈ set.compl A ↔ x ∉ A ', 'lean_line': 158, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 159
DEBUG     Course initialisation: Parsing line 160
DEBUG     Course initialisation: Parsing line 161
DEBUG     Course initialisation: Parsing line 162
DEBUG     Course initialisation: Parsing line 163
DEBUG     Course initialisation: Parsing line 164
DEBUG     Course initialisation: Parsing line 165
DEBUG     Course initialisation: Parsing line 166
DEBUG     Course initialisation: Parsing line 167
DEBUG     Course initialisation: Parsing line 168
DEBUG     Course initialisation: Parsing line 169
DEBUG     Course initialisation: Parsing line 170
DEBUG     Course initialisation: Parsing line 171
DEBUG     Course initialisation: Parsing line 172
INFO      Course initialisation: creating exercise from data {'PrettyName': ' Complémentaire du complémentaire', 'Description': ' Tout ensemble est égal au complémentaire de son complémentaire', 'lean_name': 'theorie_des_ensembles.complementaire.exercise.complement_complement', 'lean_statement': ': (set.compl (set.compl A)) =A ', 'lean_line': 172, 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 173
DEBUG     Course initialisation: Parsing line 174
DEBUG     Course initialisation: Parsing line 175
DEBUG     Course initialisation: Parsing line 176
DEBUG     Course initialisation: Parsing line 177
DEBUG     Course initialisation: Parsing line 178
DEBUG     Course initialisation: Parsing line 179
DEBUG     Course initialisation: Parsing line 180
DEBUG     Course initialisation: Parsing line 181
DEBUG     Course initialisation: Parsing line 182
DEBUG     Course initialisation: Parsing line 183
INFO      Course initialisation: creating exercise from data {'PrettyName': " Complémentaire d'union I", 'Description': " Le complémentaire de l'union de deux ensembles égale l'intersection des complémentaires", 'lean_name': 'theorie_des_ensembles.complementaire.exercise.complement_union_deux', 'lean_statement': ': set.compl (A ∪ B) = (set.compl A) ∩ (set.compl B) ', 'lean_line': 183, 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 184
DEBUG     Course initialisation: Parsing line 185
DEBUG     Course initialisation: Parsing line 186
DEBUG     Course initialisation: Parsing line 187
DEBUG     Course initialisation: Parsing line 188
DEBUG     Course initialisation: Parsing line 189
DEBUG     Course initialisation: Parsing line 190
DEBUG     Course initialisation: Parsing line 191
DEBUG     Course initialisation: Parsing line 192
DEBUG     Course initialisation: Parsing line 193
DEBUG     Course initialisation: Parsing line 194
DEBUG     Course initialisation: Parsing line 195
INFO      Course initialisation: creating exercise from data {'PrettyName': " Complémentaire d'union II", 'Description': " Le complémentaire d'une réunion quelconque égale l'intersection des complémentaires", 'lean_name': 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque', 'lean_statement': '(H : ∀ i, F i = set.compl (E i)) : set.compl (set.Union E) = set.Inter F ', 'lean_line': 195, 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 196
DEBUG     Course initialisation: Parsing line 197
DEBUG     Course initialisation: Parsing line 198
DEBUG     Course initialisation: Parsing line 199
DEBUG     Course initialisation: Parsing line 200
DEBUG     Course initialisation: Parsing line 201
DEBUG     Course initialisation: Parsing line 202
DEBUG     Course initialisation: Parsing line 203
DEBUG     Course initialisation: Parsing line 204
DEBUG     Course initialisation: Parsing line 205
DEBUG     Course initialisation: Parsing line 206
INFO      Course initialisation: creating exercise from data {'PrettyName': ' Le passage au complémentaire renverse les inclusions', 'Description': ' Si A est inclus dans B, alors le complémentaire de A contient le complémentaire de B', 'lean_name': 'theorie_des_ensembles.complementaire.exercise.inclusion_complement', 'lean_statement': ':\nA ⊆ B → set.compl B ⊆ set.compl A\n', 'lean_line': 206, 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 207
DEBUG     Course initialisation: Parsing line 208
DEBUG     Course initialisation: Parsing line 209
DEBUG     Course initialisation: Parsing line 210
DEBUG     Course initialisation: Parsing line 211
DEBUG     Course initialisation: Parsing line 212
DEBUG     Course initialisation: Parsing line 213
DEBUG     Course initialisation: Parsing line 214
DEBUG     Course initialisation: Parsing line 215
DEBUG     Course initialisation: Parsing line 216
DEBUG     Course initialisation: Parsing line 217
DEBUG     Course initialisation: Parsing line 218
DEBUG     Course initialisation: Parsing line 219
DEBUG     Course initialisation: Parsing line 220
DEBUG     Course initialisation: Parsing line 221
DEBUG     Course initialisation: closing namespace
DEBUG     Course initialisation: Parsing line 222
DEBUG     Course initialisation: Parsing line 223
DEBUG     Course initialisation: Parsing line 224
DEBUG     Course initialisation: Parsing line 225
DEBUG     Course initialisation: Parsing line 226
DEBUG     Course initialisation: Parsing line 227
DEBUG     Course initialisation: Parsing line 228
DEBUG     Course initialisation: Parsing line 229
DEBUG     Course initialisation: Parsing line 230
DEBUG     Course initialisation: Parsing line 231
DEBUG     Course initialisation: Parsing line 232
DEBUG     Course initialisation: Parsing line 233
DEBUG     Course initialisation: namespace theorie_des_ensembles.applications
DEBUG     Course initialisation: Parsing line 234
DEBUG     Course initialisation: Parsing line 235
DEBUG     Course initialisation: Parsing line 236
DEBUG     Course initialisation: Parsing line 237
DEBUG     Course initialisation: Parsing line 238
DEBUG     Course initialisation: Parsing line 239
DEBUG     Course initialisation: Parsing line 240
DEBUG     Course initialisation: Parsing line 241
DEBUG     Course initialisation: Parsing line 242
DEBUG     Course initialisation: Parsing line 243
DEBUG     Course initialisation: Parsing line 244
DEBUG     Course initialisation: Parsing line 245
DEBUG     Course initialisation: Parsing line 246
DEBUG     Course initialisation: Parsing line 247
DEBUG     Course initialisation: Parsing line 248
DEBUG     Course initialisation: Parsing line 249
DEBUG     Course initialisation: Parsing line 250
INFO      Course initialisation: creating definition from data {'lean_name': 'theorie_des_ensembles.applications.definition.image_directe', 'lean_statement': "(y : Y) : y ∈ f '' A ↔ ∃ x : X, x ∈ A ∧  f x = y ", 'PrettyName': 'Image directe', 'lean_line': 250, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 251
DEBUG     Course initialisation: Parsing line 252
DEBUG     Course initialisation: Parsing line 253
DEBUG     Course initialisation: Parsing line 254
DEBUG     Course initialisation: Parsing line 255
DEBUG     Course initialisation: Parsing line 256
DEBUG     Course initialisation: Parsing line 257
INFO      Course initialisation: creating definition from data {'lean_name': 'theorie_des_ensembles.applications.definition.image_reciproque', 'lean_statement': "(x:X) : x ∈ f  ⁻¹' B ↔ f(x) ∈ B ", 'PrettyName': 'Image reciproque', 'lean_line': 257, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 258
DEBUG     Course initialisation: Parsing line 259
DEBUG     Course initialisation: Parsing line 260
DEBUG     Course initialisation: Parsing line 261
DEBUG     Course initialisation: Parsing line 262
DEBUG     Course initialisation: Parsing line 263
DEBUG     Course initialisation: Parsing line 264
DEBUG     Course initialisation: Parsing line 265
DEBUG     Course initialisation: Parsing line 266
DEBUG     Course initialisation: Parsing line 267
INFO      Course initialisation: creating exercise from data {'lean_name': 'theorie_des_ensembles.applications.exercise.image_de_reciproque', 'lean_statement': ": f '' (f ⁻¹' B)  ⊆ B ", 'PrettyName': 'Image de reciproque', 'lean_line': 267, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 268
DEBUG     Course initialisation: Parsing line 269
DEBUG     Course initialisation: Parsing line 270
DEBUG     Course initialisation: Parsing line 271
DEBUG     Course initialisation: Parsing line 272
DEBUG     Course initialisation: Parsing line 273
DEBUG     Course initialisation: Parsing line 274
DEBUG     Course initialisation: Parsing line 275
DEBUG     Course initialisation: Parsing line 276
DEBUG     Course initialisation: Parsing line 277
DEBUG     Course initialisation: Parsing line 278
DEBUG     Course initialisation: Parsing line 279
INFO      Course initialisation: creating exercise from data {'lean_name': 'theorie_des_ensembles.applications.exercise.image_reciproque_inter', 'lean_statement': ":  f ⁻¹'  (B∩B') = f ⁻¹'  (B) ∩ f ⁻¹'  (B') ", 'PrettyName': 'Image reciproque inter', 'lean_line': 279, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 280
DEBUG     Course initialisation: Parsing line 281
DEBUG     Course initialisation: Parsing line 282
DEBUG     Course initialisation: Parsing line 283
DEBUG     Course initialisation: Parsing line 284
INFO      Course initialisation: creating exercise from data {'lean_name': 'theorie_des_ensembles.applications.exercise.image_reciproque_union', 'lean_statement': ": f ⁻¹' (B ∪ B') = f ⁻¹' B ∪ f ⁻¹' B'\n", 'PrettyName': 'Image reciproque union', 'lean_line': 284, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 285
DEBUG     Course initialisation: Parsing line 286
DEBUG     Course initialisation: Parsing line 287
DEBUG     Course initialisation: Parsing line 288
DEBUG     Course initialisation: Parsing line 289
DEBUG     Course initialisation: Parsing line 290
INFO      Course initialisation: creating exercise from data {'lean_name': 'theorie_des_ensembles.applications.exercise.image_reciproque_inter_quelconque', 'lean_statement': "(H : ∀ i:I,  (E i = f ⁻¹' (F i))) :\n(f ⁻¹'  (set.Inter F)) = set.Inter E\n", 'PrettyName': 'Image reciproque inter quelconque', 'lean_line': 290, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 291
DEBUG     Course initialisation: Parsing line 292
DEBUG     Course initialisation: Parsing line 293
DEBUG     Course initialisation: Parsing line 294
DEBUG     Course initialisation: Parsing line 295
DEBUG     Course initialisation: Parsing line 296
DEBUG     Course initialisation: Parsing line 297
DEBUG     Course initialisation: Parsing line 298
DEBUG     Course initialisation: Parsing line 299
INFO      Course initialisation: creating exercise from data {'lean_name': 'theorie_des_ensembles.applications.exercise.image_inter_inclus_inter_images', 'lean_statement': ":\nf '' (A∩A') ⊆ f '' (A) ∩ f '' (A')\n", 'PrettyName': 'Image inter inclus inter images', 'lean_line': 299, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 300
DEBUG     Course initialisation: Parsing line 301
DEBUG     Course initialisation: Parsing line 302
DEBUG     Course initialisation: Parsing line 303
DEBUG     Course initialisation: Parsing line 304
DEBUG     Course initialisation: Parsing line 305
DEBUG     Course initialisation: Parsing line 306
INFO      Course initialisation: creating exercise from data {'lean_name': 'theorie_des_ensembles.applications.exercise.reciproque_complementaire', 'lean_statement': ":\nf ⁻¹' (set.compl B) = set.compl (f ⁻¹' B)\n", 'PrettyName': 'Reciproque complementaire', 'lean_line': 306, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 307
DEBUG     Course initialisation: Parsing line 308
DEBUG     Course initialisation: Parsing line 309
DEBUG     Course initialisation: Parsing line 310
DEBUG     Course initialisation: Parsing line 311
DEBUG     Course initialisation: Parsing line 312
DEBUG     Course initialisation: Parsing line 313
DEBUG     Course initialisation: Parsing line 314
DEBUG     Course initialisation: Parsing line 315
DEBUG     Course initialisation: Parsing line 316
DEBUG     Course initialisation: Parsing line 317
DEBUG     Course initialisation: namespace theorie_des_ensembles.applications.injections_surjections
DEBUG     Course initialisation: Parsing line 318
DEBUG     Course initialisation: Parsing line 319
DEBUG     Course initialisation: Parsing line 320
DEBUG     Course initialisation: Parsing line 321
DEBUG     Course initialisation: Parsing line 322
DEBUG     Course initialisation: Parsing line 323
DEBUG     Course initialisation: Parsing line 324
DEBUG     Course initialisation: Parsing line 325
DEBUG     Course initialisation: Parsing line 326
DEBUG     Course initialisation: Parsing line 327
DEBUG     Course initialisation: Parsing line 328
DEBUG     Course initialisation: Parsing line 329
DEBUG     Course initialisation: Parsing line 330
DEBUG     Course initialisation: Parsing line 331
DEBUG     Course initialisation: Parsing line 332
DEBUG     Course initialisation: Parsing line 333
DEBUG     Course initialisation: Parsing line 334
INFO      Course initialisation: creating definition from data {'lean_name': 'theorie_des_ensembles.applications.injections_surjections.definition.injectivite', 'lean_statement': ':\ninjective f ↔ ∀ x y : X, (f x = f y → x = y)\n', 'PrettyName': 'Injectivite', 'lean_line': 334, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 335
DEBUG     Course initialisation: Parsing line 336
DEBUG     Course initialisation: Parsing line 337
DEBUG     Course initialisation: Parsing line 338
DEBUG     Course initialisation: Parsing line 339
DEBUG     Course initialisation: Parsing line 340
DEBUG     Course initialisation: Parsing line 341
INFO      Course initialisation: creating definition from data {'lean_name': 'theorie_des_ensembles.applications.injections_surjections.definition.surjectivite', 'lean_statement': ':\nsurjective f ↔ ∀ y : Y, ∃ x : X, f x = y\n', 'PrettyName': 'Surjectivite', 'lean_line': 341, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 342
DEBUG     Course initialisation: Parsing line 343
DEBUG     Course initialisation: Parsing line 344
DEBUG     Course initialisation: Parsing line 345
DEBUG     Course initialisation: Parsing line 346
DEBUG     Course initialisation: Parsing line 347
DEBUG     Course initialisation: Parsing line 348
INFO      Course initialisation: creating definition from data {'lean_name': 'theorie_des_ensembles.applications.injections_surjections.definition.composition', 'lean_statement': ':\nh = composition g f ↔ ∀ x : X, h x = g (f x)\n', 'PrettyName': 'Composition', 'lean_line': 348, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: Parsing line 349
DEBUG     Course initialisation: Parsing line 350
DEBUG     Course initialisation: Parsing line 351
DEBUG     Course initialisation: Parsing line 352
DEBUG     Course initialisation: Parsing line 353
DEBUG     Course initialisation: Parsing line 354
DEBUG     Course initialisation: Parsing line 355
DEBUG     Course initialisation: Parsing line 356
DEBUG     Course initialisation: Parsing line 357
DEBUG     Course initialisation: Parsing line 358
DEBUG     Course initialisation: Parsing line 359
DEBUG     Course initialisation: Parsing line 360
INFO      Course initialisation: creating exercise from data {'lean_name': 'theorie_des_ensembles.applications.injections_surjections.exercise.composition_injections', 'lean_statement': '(H0 : h = composition g f)\n(H1 : injective f) (H2 : injective g) :\ninjective h\n', 'PrettyName': 'Composition injections', 'lean_line': 360, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 361
DEBUG     Course initialisation: Parsing line 362
DEBUG     Course initialisation: Parsing line 363
DEBUG     Course initialisation: Parsing line 364
DEBUG     Course initialisation: Parsing line 365
DEBUG     Course initialisation: Parsing line 366
DEBUG     Course initialisation: Parsing line 367
DEBUG     Course initialisation: Parsing line 368
INFO      Course initialisation: creating exercise from data {'lean_name': 'theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections', 'lean_statement': '(H0 : h = composition g f)\n(H1 : surjective f) (H2 : surjective g) :\nsurjective h\n', 'PrettyName': 'Composition surjections', 'lean_line': 368, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 369
DEBUG     Course initialisation: Parsing line 370
DEBUG     Course initialisation: Parsing line 371
DEBUG     Course initialisation: Parsing line 372
DEBUG     Course initialisation: Parsing line 373
DEBUG     Course initialisation: Parsing line 374
DEBUG     Course initialisation: Parsing line 375
DEBUG     Course initialisation: Parsing line 376
INFO      Course initialisation: creating exercise from data {'lean_name': 'theorie_des_ensembles.applications.injections_surjections.exercise.injective_si_coompo_injective', 'lean_statement': '(H0 : h = composition g f)\n(H1 : injective h) :\ninjective f\n', 'PrettyName': 'Injective si coompo injective', 'lean_line': 376, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 377
DEBUG     Course initialisation: Parsing line 378
DEBUG     Course initialisation: Parsing line 379
DEBUG     Course initialisation: Parsing line 380
DEBUG     Course initialisation: Parsing line 381
DEBUG     Course initialisation: Parsing line 382
DEBUG     Course initialisation: Parsing line 383
DEBUG     Course initialisation: Parsing line 384
INFO      Course initialisation: creating exercise from data {'lean_name': 'theorie_des_ensembles.applications.injections_surjections.exercise.surjective_si_coompo_surjective', 'lean_statement': '(H0 : h = composition g f)\n(H1 : surjective h) :\nsurjective g\n', 'PrettyName': 'Surjective si coompo surjective', 'lean_line': 384, 'Description': 'NOT PROVIDED', 'text_book_identifier': 'NOT IMPLEMENTED', 'lean_variables': 'NOT IMPLEMENTED', 'Tools->Logic': None, 'Tools->Magic': None, 'Tools->ProofTechniques': None, 'Tools->Definitions': None, 'Tools->Theorems': None, 'Tools->Exercises': None, 'Tools->Statements': None}
DEBUG     Course initialisation: processing data in Tools->Definitions, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Theorems, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Exercises, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Statements, $UNTIL_NOW
DEBUG     Course initialisation: processing data in Tools->Logic, None
DEBUG     Course initialisation: found logic names ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 2: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: list 3: ['and', 'or', 'negate', 'implicate', 'iff', 'forall', 'exists', 'substitution']
DEBUG     Course initialisation: processing data in Tools->ProofTechniques, None
DEBUG     Course initialisation: found proofs names ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 2: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: list 3: ['cbr', 'contrapose', 'absurdum', 'new_object', 'assumption']
DEBUG     Course initialisation: processing data in Tools->Magic, None
DEBUG     Course initialisation: found magic names ['compute']
DEBUG     Course initialisation: list 2: ['compute']
DEBUG     Course initialisation: list 3: ['compute']
DEBUG     Course initialisation: Parsing line 385
DEBUG     Course initialisation: Parsing line 386
DEBUG     Course initialisation: Parsing line 387
DEBUG     Course initialisation: Parsing line 388
DEBUG     Course initialisation: Parsing line 389
DEBUG     Course initialisation: Parsing line 390
DEBUG     Course initialisation: Parsing line 391
DEBUG     Course initialisation: Parsing line 392
DEBUG     Course initialisation: Parsing line 393
DEBUG     Course initialisation: closing namespace
DEBUG     Course initialisation: Parsing line 394
DEBUG     Course initialisation: Parsing line 395
DEBUG     Course initialisation: closing namespace
DEBUG     Course initialisation: Parsing line 396
DEBUG     Course initialisation: Parsing line 397
DEBUG     Course initialisation: closing namespace
INFO      Course initialisation: 29 statements, including 16 exercises found by parser
INFO      lean           : Started server
INFO      ServerInterface: Set exercise to: theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections -> Composition surjections
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections", "content": "import data.set\nimport tactic\n\n-- dEAduction imports\nimport logics\nimport definitions\nimport structures\n\nlocal attribute [instance] classical.prop_decidable\n\n-----------------\n-- Course Data --\n-----------------\n/- dEAduction\nCourseTitle\n    Th\u00e9orie des Ensembles\nAuthor\n    Camille Nous\nDate\n    08/2020\nUniversity\n    Some French University\nCourseId\n    1MA999\n-/\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\n-- global variable --\nvariable {X : Type}\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\nlemma definition.inclusion (A B : set X) : A \u2286 B \u2194 \u2200 {{x:X}}, x \u2208 A \u2192 x \u2208 B :=\niff.rfl\n\nlemma definition.egalite_deux_ensembles {A A' : set X} : (A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nby exact set.ext_iff\n\nlemma theorem.double_inclusion {A A' : set X} : (A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\n\n\n\n\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.intersection_deux_ensembles (A B : set X) (x : X) :  x \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\niff.rfl\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\n\nlemma definition.intersection_quelconque_ensembles (I : Type) (O : I \u2192 set X)  (x : X) : (x \u2208 set.Inter O) \u2194 (\u2200 i:I, x \u2208 O i) :=\nset.mem_Inter\n/- dEAduction\nPrettyName\n    Intersection d'une famille d'ensembles quelconque\n-/\n\nlemma definition.union_deux_ensembles  (A : set X) (B : set X) (x : X) :  x \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\niff.rfl\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\n\nlemma definition.union_quelconque_ensembles (I : Type) (O : I \u2192 set X)  (x : X) : (x \u2208 set.Union O) \u2194 (\u2203 i:I, x \u2208 O i) :=\nset.mem_Union\n/- dEAduction\nPrettyName\n    Union d'une famille d'ensembles quelconque\n-/\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection d'une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL -negate\nTools->ProofTechniques\n    $ALL -contradiction\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\n\nbegin\n    sorry\nend\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    L'union est distributive par rapport \u00e0 l'intersection\n-/\nbegin\n    sorry\nend\n\nend unions_et_intersections\n\n\n\n\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\nnotation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nby finish\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) =A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux : set.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.all true\nlemma exercise.complement_union_quelconque  (H : \u2200 i, F i = set.compl (E i)) : set.compl (set.Union E) = set.Inter F :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications\n-- variables applications --\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\n\nvariables  {A A': set X}\nvariables {Y: Type} {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\n/- dEAduction -/\nbegin\n    unfold set.image,\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\n/- dEAduction -/\nbegin\n    sorry\nend\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\nbegin\n  sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter_quelconque (H : \u2200 i:I,  (E i = f \u207b\u00b9' (F i))) :\n(f \u207b\u00b9'  (set.Inter F)) = set.Inter E\n:=\nbegin\n    sorry\nend\n\n/- Idem union quelconques -/\n\nlemma exercise.image_inter_inclus_inter_images :\nf '' (A\u2229A') \u2286 f '' (A) \u2229 f '' (A')\n:=\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_complementaire :\nf \u207b\u00b9' (set.compl B) = set.compl (f \u207b\u00b9' B)\n:=\nbegin\n    sorry\nend\n\n\n----------------\n-- SUBSECTION --\n----------------\nnamespace injections_surjections\n/- dEAduction\nPrettyName\n    injections et surjections\n-/\n\n\n-- variables injections_usrjections --\nvariables {Z : Type} {g : Y \u2192 Z} {h : X \u2192 Z}\ndef injective (f\u2080 : X \u2192 Y) := \u2200 x y : X, (f\u2080 x = f\u2080 y \u2192 x = y)\ndef surjective (f\u2080 : X \u2192 Y) := \u2200 y : Y, \u2203 x : X, f\u2080 x = y\ndef composition (g\u2080 : Y \u2192 Z) (f\u2080 : X \u2192 Y) := \u03bbx:X, g\u2080 (f\u2080 x)\n#print injective\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.injectivite :\ninjective f \u2194 \u2200 x y : X, (f x = f y \u2192 x = y)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.surjectivite :\nsurjective f \u2194 \u2200 y : Y, \u2203 x : X, f x = y\n:=\nbegin\n    sorry,\nend\n\nlemma definition.composition :\nh = composition g f \u2194 \u2200 x : X, h x = g (f x)\n:=\nbegin\n    unfold composition,\n    sorry\nend\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.composition_injections (H0 : h = composition g f)\n(H1 : injective f) (H2 : injective g) :\ninjective h\n:=\nbegin\n    sorry\nend\n\nlemma exercise.composition_surjections (H0 : h = composition g f)\n(H1 : surjective f) (H2 : surjective g) :\nsurjective h\n:=\nbegin\nhypo_analysis,\ntargets_analysis,\nend\n\nlemma exercise.injective_si_coompo_injective (H0 : h = composition g f)\n(H1 : injective h) :\ninjective f\n:=\nbegin\n    sorry\nend\n\nlemma exercise.surjective_si_coompo_surjective (H0 : h = composition g f)\n(H1 : surjective h) :\nsurjective g\n:=\nbegin\n    sorry\nend\n\n\nend injections_surjections\n\nend applications\n\nend theorie_des_ensembles", "seq_num": 0, "command": "sync"}
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":0}
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":125,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/definitions.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":125,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/definitions.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":125,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/definitions.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":125,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/definitions.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":125,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/definitions.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":125,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/definitions.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":1},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 10","end_pos_col":1,"end_pos_line":125,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/definitions.lean","pos_col":0,"pos_line":10},{"desc":"parsing at line 9","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":9},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 58","end_pos_col":1,"end_pos_line":125,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/definitions.lean","pos_col":0,"pos_line":58},{"desc":"parsing at line 44","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":44},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 95","end_pos_col":1,"end_pos_line":125,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/definitions.lean","pos_col":0,"pos_line":95},{"desc":"parsing at line 44","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":44},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 44","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":44},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 44","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":44},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 162","end_pos_col":1,"end_pos_line":178,"file_name":"/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/share/lean_src/structures.lean","pos_col":0,"pos_line":162},{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 1","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":1}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"theorie_des_ensembles.definition.egalite_deux_ensembles","end_pos_col":0,"end_pos_line":52,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":45},{"desc":"theorie_des_ensembles.definition.egalite_deux_ensembles","end_pos_col":0,"end_pos_line":52,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":45},{"desc":"theorie_des_ensembles.definition.egalite_deux_ensembles","end_pos_col":0,"end_pos_line":52,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":45},{"desc":"theorie_des_ensembles.theorem.double_inclusion","end_pos_col":0,"end_pos_line":69,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":52},{"desc":"theorie_des_ensembles.theorem.double_inclusion","end_pos_col":0,"end_pos_line":69,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":52},{"desc":"theorie_des_ensembles.theorem.double_inclusion","end_pos_col":0,"end_pos_line":69,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":52},{"desc":"parsing at line 76","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":76}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":108,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":130,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":172,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":183,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":195,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":206,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement' uses sorry"}],"response":"all_messages"}
WARNING   ServerInterface: Lean warning at line 108: declaration 'theorie_des_ensembles.unions_et_intersections.exercise.union_distributive_inter' uses sorry
WARNING   ServerInterface: Lean warning at line 130: declaration 'theorie_des_ensembles.unions_et_intersections.exercise.inter_distributive_union' uses sorry
WARNING   ServerInterface: Lean warning at line 172: declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry
WARNING   ServerInterface: Lean warning at line 183: declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry
WARNING   ServerInterface: Lean warning at line 195: declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry
WARNING   ServerInterface: Lean warning at line 206: declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement' uses sorry
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"theorie_des_ensembles.complementaire.definition.complement","end_pos_col":0,"end_pos_line":172,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":158},{"desc":"theorie_des_ensembles.complementaire.definition.complement","end_pos_col":0,"end_pos_line":172,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":158},{"desc":"theorie_des_ensembles.complementaire.definition.complement","end_pos_col":0,"end_pos_line":172,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":158},{"desc":"theorie_des_ensembles.applications.definition.image_directe","end_pos_col":0,"end_pos_line":257,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":250},{"desc":"theorie_des_ensembles.applications.definition.image_directe","end_pos_col":0,"end_pos_line":257,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":250},{"desc":"theorie_des_ensembles.applications.definition.image_directe","end_pos_col":0,"end_pos_line":257,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":250},{"desc":"theorie_des_ensembles.applications.definition.image_reciproque","end_pos_col":0,"end_pos_line":267,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":257},{"desc":"theorie_des_ensembles.applications.exercise.image_de_reciproque","end_pos_col":0,"end_pos_line":272,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":267},{"desc":"theorie_des_ensembles.applications.exercise.reciproque_de_image","end_pos_col":0,"end_pos_line":279,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":272},{"desc":"theorie_des_ensembles.applications.exercise.image_reciproque_inter","end_pos_col":0,"end_pos_line":284,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":279},{"desc":"theorie_des_ensembles.applications.exercise.image_reciproque_union","end_pos_col":0,"end_pos_line":290,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":284},{"desc":"theorie_des_ensembles.applications.exercise.image_reciproque_union","end_pos_col":0,"end_pos_line":290,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":284},{"desc":"theorie_des_ensembles.applications.exercise.image_reciproque_union","end_pos_col":0,"end_pos_line":290,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":284},{"desc":"theorie_des_ensembles.applications.exercise.image_reciproque_inter_quelconque","end_pos_col":0,"end_pos_line":299,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":290},{"desc":"theorie_des_ensembles.applications.exercise.image_reciproque_inter_quelconque","end_pos_col":0,"end_pos_line":299,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":290},{"desc":"theorie_des_ensembles.applications.exercise.image_reciproque_inter_quelconque","end_pos_col":0,"end_pos_line":299,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":290},{"desc":"parsing at line 299","end_pos_col":26,"end_pos_line":398,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":299}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":108,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":130,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":172,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":183,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":195,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":206,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":257,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":267,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":272,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":279,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":284,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications.exercise.image_reciproque_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications.exercise.image_reciproque_inter_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":299,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications.exercise.image_inter_inclus_inter_images' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":306,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications.exercise.reciproque_complementaire' uses sorry"},{"caption":"print result","end_pos_col":0,"end_pos_line":334,"file_name":"theorie_des_ensembles.applications.injections_surjections.exercise.composition_surjections","pos_col":0,"pos_line":329,"severity":"information","text":"def theorie_des_ensembles.applications.injections_surjections.injective : Π {X Y : Type}, (X → Y) → Prop :=\nλ {X Y : Type} (f₀ : X → Y), ∀ (x y : X), f₀ x = f₀ y → x = y"}],"response":"all_messages"}
WARNING   ServerInterface: Lean warning at line 108: declaration 'theorie_des_ensembles.unions_et_intersections.exercise.union_distributive_inter' uses sorry
WARNING   ServerInterface: Lean warning at line 130: declaration 'theorie_des_ensembles.unions_et_intersections.exercise.inter_distributive_union' uses sorry
WARNING   ServerInterface: Lean warning at line 172: declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry
WARNING   ServerInterface: Lean warning at line 183: declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry
WARNING   ServerInterface: Lean warning at line 195: declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry
WARNING   ServerInterface: Lean warning at line 206: declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement' uses sorry
WARNING   ServerInterface: Lean warning at line 250: declaration 'theorie_des_ensembles.applications.definition.image_directe' uses sorry
WARNING   ServerInterface: Lean warning at line 257: declaration 'theorie_des_ensembles.applications.definition.image_reciproque' uses sorry
WARNING   ServerInterface: Lean warning at line 267: declaration 'theorie_des_ensembles.applications.exercise.image_de_reciproque' uses sorry
WARNING   ServerInterface: Lean warning at line 272: declaration 'theorie_des_ensembles.applications.exercise.reciproque_de_image' uses sorry
WARNING   ServerInterface: Lean warning at line 279: declaration 'theorie_des_ensembles.applications.exercise.image_reciproque_inter' uses sorry
WARNING   ServerInterface: Lean warning at line 284: declaration 'theorie_des_ensembles.applications.exercise.image_reciproque_union' uses sorry
WARNING   ServerInterface: Lean warning at line 290: declaration 'theorie_des_ensembles.applications.exercise.image_reciproque_inter_quelconque' uses sorry
WARNING   ServerInterface: Lean warning at line 299: declaration 'theorie_des_ensembles.applications.exercise.image_inter_inclus_inter_images' uses sorry
WARNING   ServerInterface: Lean warning at line 306: declaration 'theorie_des_ensembles.applications.exercise.reciproque_complementaire' uses sorry
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
--- Error(IndexError('list index out of range'))
Traceback (most recent call last):
  File "/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/venv/lib/python3.7/site-packages/qtrio/_core.py", line 451, in trio_main
    result = await async_fn(*args)
  File "/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/src/deaduction/dui/__main__.py", line 64, in main
    servint.stop() # Good job, buddy
  File "/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/venv/lib/python3.7/site-packages/trio/_core/_run.py", line 741, in __aexit__
    raise combined_error_from_nursery
  File "/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/src/deaduction/dui/widgets/exercise_widgets.py", line 298, in server_task
    await self.servint.exercise_set(self.exercise)
  File "/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/src/deaduction/pylib/server/__init__.py", line 230, in exercise_set
    await self.__update()
  File "/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/src/deaduction/pylib/server/__init__.py", line 170, in __update
    self.__tmp_hypo_analysis, self.__tmp_targets_analysis)
  File "/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/src/deaduction/pylib/mathobj/proof_state.py", line 239, in from_lean_data
    if targets[0].startswith("targets:"):
IndexError: list index out of range
