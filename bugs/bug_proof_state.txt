'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.36.2718'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.37.1744', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.36.2711'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.36.2715'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.36.2711'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.37.1754', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.36.2718'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.37.1754', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.36.2718'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.37.1727', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.36.2711'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.36.2711'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.37.1734', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.36.2711'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.36.2715'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.36.2711'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.36.2718'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.37.1734', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.36.2718'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.37.1727', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.36.2711'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.36.2711'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.37.1734', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.36.2711'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.36.2715'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.36.2711'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.36.2718'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.36.2713'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.37.1734', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.36.2716'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     deaduction.dui.widgets.exercise_widgets: Code sent to Lean: `[ rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2, trace "EFFECTIVE CODE 10 : rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2"] <|> `[ rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2, trace "EFFECTIVE CODE 10 : rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2"] <|> `[ simp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2, trace "EFFECTIVE CODE 10 : simp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2"] <|> `[ simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2, trace "EFFECTIVE CODE 10 : simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2"],
DEBUG     ServerInterface: Updating, checking errors from line 460, and context at line 461
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\n`[ rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2, trace \"EFFECTIVE CODE 10 : rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2\"] <|> `[ rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2, trace \"EFFECTIVE CODE 10 : rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2\"] <|> `[ simp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2, trace \"EFFECTIVE CODE 10 : simp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2\"] <|> `[ simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2, trace \"EFFECTIVE CODE 10 : simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2\"],\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 12, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":12}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":460,"severity":"information","text":"EFFECTIVE CODE 10 : simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.38.3112¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.38.3115¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.39.1723¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]\n¿¿¿property¿[pp_type: ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.39.2122¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2148¿]¿, PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.39.1723¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.38.3112¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.38.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2148¿]¿)¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.39.2131¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.39.1723¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2155¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.38.3112¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.38.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2155¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.39.1695¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2166¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.38.3112¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.38.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2166¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.38.3112¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2176¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.38.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2176¿]¿)¿)¿)¿)¿)\n"}],"response":"all_messages"}
INFO      ServerInterface: Got EFFECTIVE CODE 10 : simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2
 at line 460
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.38.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.38.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.39.1723'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': '∀ (i : I), x ∈ (f⁻¹⟮F i⟯)', 'name': 'H2', 'identifier': '0._fresh.39.2122'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2148', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.39.1723'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.38.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.38.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2148', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.39.2131'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.39.1723'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2155', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.38.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.38.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2155', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.39.1695'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2166', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.38.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.38.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2166', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.38.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2176', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.38.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2176', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.38.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.38.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2148', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2155', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.38.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.38.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2155', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.38.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.38.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2148', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2155', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.38.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.38.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.38.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.38.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.39.2155', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.38.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":460,"severity":"information","text":"EFFECTIVE CODE 10 : simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.38.3112¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.38.3115¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.39.1723¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]\n¿¿¿property¿[pp_type: ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.39.2122¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2148¿]¿, PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.39.1723¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.38.3112¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.38.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2148¿]¿)¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.39.2131¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.39.1723¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2155¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.38.3112¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.38.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2155¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.39.1695¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2166¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.38.3112¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.38.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2166¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.38.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.38.3112¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.38.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2176¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.38.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.38.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.39.2176¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got EFFECTIVE CODE 10 : simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2
 at line 460
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 463: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     deaduction.dui.widgets.exercise_widgets: Code sent to Lean: `[ rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2, trace "EFFECTIVE CODE 11 : rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2"] <|> `[ rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2, trace "EFFECTIVE CODE 11 : rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2"] <|> `[ simp_rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2, trace "EFFECTIVE CODE 11 : simp_rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2"] <|> `[ simp_rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2, trace "EFFECTIVE CODE 11 : simp_rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2"],
DEBUG     ServerInterface: Updating, checking errors from line 461, and context at line 462
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nsimp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\n`[ rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2, trace \"EFFECTIVE CODE 11 : rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2\"] <|> `[ rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2, trace \"EFFECTIVE CODE 11 : rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2\"] <|> `[ simp_rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2, trace \"EFFECTIVE CODE 11 : simp_rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2\"] <|> `[ simp_rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2, trace \"EFFECTIVE CODE 11 : simp_rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2\"],\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 13, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":13}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"information","text":"EFFECTIVE CODE 11 : rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.40.3507¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.40.3509¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.40.3507¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.40.3510¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.40.3512¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.40.3510¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.40.3507¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.41.1781¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.41.2103¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.41.1781¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.40.3510¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.40.3510¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.41.2121¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.40.3509¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.40.3507¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.40.3512¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.41.2121¿]¿)¿)¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.41.2108¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.41.1781¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.40.3510¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.40.3510¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.41.2131¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.40.3509¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.40.3507¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.40.3512¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.41.2131¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.41.1753¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.40.3510¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.40.3510¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.41.2140¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.40.3509¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.40.3507¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.40.3512¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.41.2140¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.40.3505¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.40.3509¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.40.3507¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.40.3510¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.40.3507¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.40.3510¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.41.2150¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.40.3507¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.40.3512¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.41.2150¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":464,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got EFFECTIVE CODE 11 : rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2
 at line 461
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 464: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.40.3509'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.40.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.41.1781'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': 'H2', 'identifier': '0._fresh.41.2103'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.41.1781'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.41.2121', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.40.3509'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.40.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.41.2121', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.41.2108'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.41.1781'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.41.2131', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.40.3509'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.40.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.41.2131', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.41.1753'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.41.2140', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.40.3509'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.40.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.41.2140', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.40.3509'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.40.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.41.2150', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.40.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.40.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.41.2150', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.40.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
Traceback (most recent call last):
  File "/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/src/deaduction/dui/widgets/exercise_widgets.py", line 783, in update_proof_state
    self.update_goal(proofstate.goals[0])
  File "/Users/leroux/Documents/PROGRAMMATION/LEAN/LEAN_TRAVAIL/dEAduction/src/deaduction/dui/widgets/exercise_widgets.py", line 465, in update_goal
    previous_proof_state = entry_info["ProofState"]
KeyError: 'ProofState'
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","end_pos_col":0,"end_pos_line":465,"file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":445},{"desc":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","end_pos_col":0,"end_pos_line":465,"file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":445},{"desc":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","end_pos_col":0,"end_pos_line":465,"file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":445}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 460, and context at line 461
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nsimp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 14, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":14}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.42.1917¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.42.1919¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.42.1921¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.42.1917¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.42.1919¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.42.1922¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.42.1924¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.42.1922¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.42.1919¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.43.1081¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.42.1917¿]\n¿¿¿property¿[pp_type: ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.43.1366¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.42.1922¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.43.1392¿]¿, PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.43.1081¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.42.1917¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.42.1921¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.42.1919¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.42.1924¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.43.1392¿]¿)¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.43.1375¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.43.1081¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.42.1917¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.42.1922¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.42.1917¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.42.1922¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.43.1399¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.42.1917¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.42.1921¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.42.1919¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.42.1924¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.43.1399¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.43.1053¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.42.1917¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.42.1922¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.42.1917¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.42.1922¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.43.1410¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.42.1917¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.42.1921¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.42.1919¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.42.1924¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.43.1410¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.42.1917¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.42.1921¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.42.1919¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.42.1922¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.42.1919¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.42.1922¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.43.1420¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.42.1919¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.42.1924¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.43.1420¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 463: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.42.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.42.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.43.1081'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': '∀ (i : I), x ∈ (f⁻¹⟮F i⟯)', 'name': 'H2', 'identifier': '0._fresh.43.1366'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1392', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.43.1081'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.42.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.42.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1392', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.43.1375'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.43.1081'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.42.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.42.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.43.1053'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1410', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.42.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.42.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1410', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.42.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1420', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.42.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1420', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.42.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.42.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1392', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.42.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.42.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.42.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.42.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1392', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.42.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.42.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.42.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.42.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.43.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.42.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 461, and context at line 462
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nsimp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 15, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":15}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.44.2316¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.44.2318¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.44.2316¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.44.2319¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.44.2321¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.44.2319¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.44.2316¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.45.1139¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.45.1457¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.45.1139¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.44.2319¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.44.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.45.1475¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.44.2318¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.44.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.44.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.45.1475¿]¿)¿)¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.45.1462¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.45.1139¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.44.2319¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.44.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.45.1485¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.44.2318¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.44.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.44.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.45.1485¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.45.1111¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.44.2319¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.44.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.45.1494¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.44.2318¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.44.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.44.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.45.1494¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.44.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.44.2318¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.44.2316¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.44.2319¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.44.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.44.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.45.1504¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.44.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.44.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.45.1504¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":464,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 464: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.44.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.44.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.45.1139'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': 'H2', 'identifier': '0._fresh.45.1457'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.45.1139'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.44.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.44.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.45.1462'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.45.1139'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.44.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.44.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.45.1111'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1494', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.44.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.44.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1494', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.44.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1504', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.44.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1504', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.44.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.44.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.44.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.44.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.44.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.44.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.44.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.44.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.44.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.44.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.45.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.44.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
INFO      deaduction.dui.widgets.exercise_widgets: Calling action CQFD
DEBUG     deaduction.dui.widgets.exercise_widgets: Code sent to lean: apply H2
DEBUG     ServerInterface: Updating, checking errors from line 462, and context at line 463
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nsimp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\napply H2,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 16, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":16}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.46.2336¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.46.2338¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.46.2340¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.46.2336¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.46.2338¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.46.2341¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.46.2343¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.46.2341¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.46.2338¿]¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":464,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.47.1169¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.46.2336¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.46.2341¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.46.2336¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.46.2341¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.47.1539¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.46.2336¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.46.2340¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.46.2338¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.46.2343¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.47.1539¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.46.2336¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.46.2340¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.46.2338¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.46.2341¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.46.2338¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.46.2341¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.47.1550¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.46.2338¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.46.2343¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.47.1550¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":465,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 465: tactic failed, there are unsolved goals
state:
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.46.2336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.46.2338'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.46.2340'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.46.2336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.46.2338'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.46.2343'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.46.2338'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.47.1169'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.46.2336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.46.2336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.47.1539', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.46.2336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.46.2340'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.46.2336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.46.2338'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.46.2338'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.46.2343'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.46.2338'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.47.1539', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.46.2336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.46.2340'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.46.2336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.46.2338'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.46.2338'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.46.2338'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.47.1550', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.46.2338'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.46.2343'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.46.2338'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.47.1550', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°2 / 2
INFO      deaduction.dui.widgets.exercise_widgets: Current goal solved!
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.46.2341'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 461, and context at line 462
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nsimp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 17, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":17}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.2316¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.2318¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.2316¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.2319¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.2321¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.2319¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.2316¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.49.1139¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.49.1457¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.49.1139¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.2319¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.49.1475¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.2318¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.49.1475¿]¿)¿)¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.49.1462¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.49.1139¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.2319¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.49.1485¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.2318¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.49.1485¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.49.1111¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.2319¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.49.1494¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.2318¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.49.1494¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.2318¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.2316¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.2319¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.49.1504¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.49.1504¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":464,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 464: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.49.1139'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': 'H2', 'identifier': '0._fresh.49.1457'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.49.1139'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.49.1462'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.49.1139'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.49.1111'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1494', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1494', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1504', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1504', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1475', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.49.1485', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 460, and context at line 461
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nsimp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 18, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":18}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.4331¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.4333¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.4335¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.4331¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.4333¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.4336¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.4338¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.4336¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.4333¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.50.1081¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.4331¿]\n¿¿¿property¿[pp_type: ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.50.1366¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.4336¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.1392¿]¿, PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.50.1081¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.4331¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.4335¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.4333¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.4338¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.1392¿]¿)¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.50.1375¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.50.1081¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.4331¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.4336¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.4331¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.4336¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.1399¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.4331¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.4335¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.4333¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.4338¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.1399¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.50.1053¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.4331¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.4336¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.4331¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.4336¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.1410¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.4331¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.4335¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.4333¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.4338¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.1410¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.4331¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.4335¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.4333¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.4336¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.4333¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.4336¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.1420¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.4333¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.4338¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.1420¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 463: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.4335'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.4338'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.50.1081'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': '∀ (i : I), x ∈ (f⁻¹⟮F i⟯)', 'name': 'H2', 'identifier': '0._fresh.50.1366'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1392', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.50.1081'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.4335'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.4338'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1392', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.50.1375'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.50.1081'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.4335'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.4338'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.50.1053'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1410', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.4335'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.4338'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1410', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.4335'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1420', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.4338'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1420', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.4335'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.4338'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1392', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.4335'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.4338'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.4335'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.4338'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1392', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.4335'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.4331'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.4338'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.4333'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.1399', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.4336'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 459, and context at line 460
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 19, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":19}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":460,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.51.1520¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.51.1522¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.51.1524¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.51.1520¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.51.1522¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.51.1525¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.51.1527¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.51.1525¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.51.1522¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.50.2497¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.51.1520¿]\n¿¿¿property¿[pp_type: ∀ (i : I), f x ∈ F i¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.50.2542¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.51.1525¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.2559¿]¿, PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.51.1522¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.51.1524¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.50.2497¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.51.1522¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.51.1527¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.2559¿]¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.50.2545¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.50.2497¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.51.1520¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.51.1525¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.51.1520¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.51.1525¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.2566¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.51.1520¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.51.1524¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.51.1522¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.51.1527¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.2566¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.50.2469¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.51.1520¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.51.1525¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.51.1520¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.51.1525¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.2576¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.51.1520¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.51.1524¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.51.1522¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.51.1527¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.2576¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.51.1520¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.51.1524¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.51.1522¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.51.1525¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.51.1522¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.51.1525¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.2586¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.51.1522¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.51.1527¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.2586¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : ∀ (i : I), f x ∈ F i\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 462: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : ∀ (i : I), f x ∈ F i
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.51.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.51.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.50.2497'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': '∀ (i : I), f x ∈ F i', 'name': 'H2', 'identifier': '0._fresh.50.2542'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2559', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.51.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.50.2497'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.51.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2559', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.50.2545'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.50.2497'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2566', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.51.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.51.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2566', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.50.2469'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2576', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.51.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.51.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2576', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.51.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2586', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.51.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2586', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.51.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2559', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2566', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.51.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.51.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2566', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.51.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2559', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2566', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.51.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.51.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.51.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.51.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.2566', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.51.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 458, and context at line 459
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 20, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":20}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":459,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.5554¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.5558¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.5554¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.5559¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.5561¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.5559¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.50.3604¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.5554¿]\n¿¿¿property¿[pp_type: f x ∈ ⋂ (i : I), F i¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.50.3630¿]¿= PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.5558¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.50.3604¿]¿)¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.5559¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.5559¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.3646¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.5561¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.3646¿]¿)¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":460,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.50.3632¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.50.3604¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.5554¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.5559¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.5554¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.5559¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.3654¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.5554¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.5558¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.5561¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.3654¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.50.3576¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.5554¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.5559¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.5554¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.5559¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.3664¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.5554¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.5558¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.5561¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.3664¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.48.5554¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.48.5558¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.5559¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.48.5559¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.3674¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.48.5556¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.48.5561¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.50.3674¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : f x ∈ ⋂ (i : I), F i\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 461: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : f x ∈ ⋂ (i : I), F i
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.5558'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.5561'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.50.3604'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': 'f x ∈ ⋂ (i : I), F i', 'name': 'H2', 'identifier': '0._fresh.50.3630'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.5558'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.50.3604'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3646', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.5561'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3646', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.50.3632'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.50.3604'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3654', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.5558'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.5561'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3654', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.50.3576'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3664', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.5558'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.5561'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3664', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.5558'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3674', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.5561'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3674', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3646', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.5561'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3646', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3654', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.5558'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.5561'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3654', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3646', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.5561'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3646', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3654', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.48.5558'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.48.5554'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.48.5561'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.48.5556'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.50.3654', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.48.5559'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 457, and context at line 458
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 21, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":21}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":458,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.52.726¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.52.728¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.52.730¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.52.726¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.52.728¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.52.731¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.52.733¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.52.731¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.52.728¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.53.905¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.52.726¿]\n¿¿¿property¿[pp_type: x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.53.907¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.53.905¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.52.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.52.730¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.52.728¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.52.731¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.52.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.52.731¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.53.922¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.52.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.52.733¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.53.922¿]¿)¿)¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":459,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.53.908¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.53.905¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.52.726¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.52.731¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.52.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.52.731¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.53.930¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.52.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.52.730¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.52.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.52.733¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.53.930¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.53.877¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.52.726¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.52.731¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.52.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.52.731¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.53.940¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.52.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.52.730¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.52.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.52.733¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.53.940¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.52.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.52.730¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.52.728¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.52.731¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.52.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.52.731¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.53.950¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.52.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.52.733¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.53.950¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":460,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯)\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 460: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯)
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.52.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.52.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.53.905'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': 'x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': 'H2', 'identifier': '0._fresh.53.907'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.53.905'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.52.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.52.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.53.908'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.53.905'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.52.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.52.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.53.877'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.940', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.52.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.52.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.940', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.52.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.950', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.52.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.950', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.52.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.52.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.52.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.52.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.52.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.52.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.52.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.52.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.52.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.52.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.53.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.52.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 456, and context at line 457
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 22, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":22}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":457,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.54.573¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.54.575¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.54.577¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.54.573¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.54.575¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.54.578¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.54.580¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.54.578¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.54.575¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.55.847¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.54.573¿]\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":458,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯) → (x ∈ ⋂ (i : I), f⁻¹⟮F i⟯)¿]: METAVAR¿[name: _mlocal._fresh.55.848¿]¿= PROP_IMPLIES¿[type: PROP¿]¿(PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.55.847¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.54.573¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.54.577¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.54.575¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.54.578¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.54.575¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.54.578¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.55.868¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.54.575¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.54.580¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.55.868¿]¿)¿)¿)¿)¿)¿, PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.55.847¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.54.573¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.54.578¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.54.573¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.54.578¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.55.876¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.54.573¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.54.577¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.54.575¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.54.580¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.55.876¿]¿)¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.55.819¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.54.573¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.54.578¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.54.573¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.54.578¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.55.886¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.54.573¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.54.577¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.54.575¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.54.580¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.55.886¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.54.573¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.54.577¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.54.575¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.54.578¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.54.575¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.54.578¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.55.896¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.54.575¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.54.580¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.55.896¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":459,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X\n⊢ x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯) → (x ∈ ⋂ (i : I), f⁻¹⟮F i⟯)\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 459: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X
⊢ x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯) → (x ∈ ⋂ (i : I), f⁻¹⟮F i⟯)
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.54.577'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.54.580'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.55.847'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯) → (x ∈ ⋂ (i : I), f⁻¹⟮F i⟯)', 'name': '_mlocal._fresh.55.848'}, math_type=MathObject(node='PROP_IMPLIES', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.55.847'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.54.577'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.868', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.54.580'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.868', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.55.847'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.876', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.54.577'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.54.580'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.876', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.55.819'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.886', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.54.577'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.54.580'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.886', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.54.577'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.896', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.54.580'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.896', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.54.577'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.868', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.54.580'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.868', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.876', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.54.577'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.54.580'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.876', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.54.577'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.868', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.54.580'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.868', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.876', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.54.577'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.54.573'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.54.580'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.54.575'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.55.876', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.54.578'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 457, and context at line 458
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 23, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":23}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":458,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.726¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.728¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.56.730¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.726¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.728¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.731¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.56.733¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.731¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.728¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.57.905¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.726¿]\n¿¿¿property¿[pp_type: x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.57.907¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.57.905¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.56.730¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.728¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.731¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.731¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.57.922¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.56.733¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.57.922¿]¿)¿)¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":459,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.57.908¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.57.905¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.726¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.731¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.731¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.57.930¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.56.730¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.56.733¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.57.930¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.57.877¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.726¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.731¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.731¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.57.940¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.56.730¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.56.733¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.57.940¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.726¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.56.730¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.728¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.731¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.731¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.57.950¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.728¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.56.733¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.57.950¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":460,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯)\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 460: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯)
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.57.905'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': 'x ∈ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': 'H2', 'identifier': '0._fresh.57.907'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.57.905'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.57.908'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.57.905'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.57.877'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.940', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.940', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.950', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.950', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.922', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.730'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.726'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.733'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.728'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.57.930', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.731'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 458, and context at line 459
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 24, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":24}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":459,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.1949¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.56.1953¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.1949¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.1954¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.56.1956¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.1954¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.58.963¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.1949¿]\n¿¿¿property¿[pp_type: f x ∈ ⋂ (i : I), F i¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.58.989¿]¿= PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.56.1953¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.58.963¿]¿)¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.1954¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.1954¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.1005¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.56.1956¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.1005¿]¿)¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":460,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.58.991¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.58.963¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.1949¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.1954¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.1949¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.1954¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.1013¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.1949¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.56.1953¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.56.1956¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.1013¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.58.935¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.1949¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.1954¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.1949¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.1954¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.1023¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.1949¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.56.1953¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.56.1956¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.1023¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.56.1949¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.56.1953¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.1954¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.56.1954¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.1033¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.56.1951¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.56.1956¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.1033¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : f x ∈ ⋂ (i : I), F i\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 461: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : f x ∈ ⋂ (i : I), F i
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.1953'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.1956'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.58.963'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': 'f x ∈ ⋂ (i : I), F i', 'name': 'H2', 'identifier': '0._fresh.58.989'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.1953'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.58.963'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1005', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.1956'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1005', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.58.991'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.58.963'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1013', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.1953'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.1956'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1013', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.58.935'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1023', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.1953'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.1956'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1023', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.1953'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1033', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.1956'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1033', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1005', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.1956'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1005', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1013', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.1953'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.1956'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1013', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1005', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.1956'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1005', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1013', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.56.1953'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.56.1949'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.56.1956'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.56.1951'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.1013', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.56.1954'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 459, and context at line 460
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 25, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":25}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":460,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.59.1520¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.59.1522¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.59.1524¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.59.1520¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.59.1522¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.59.1525¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.59.1527¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.59.1525¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.59.1522¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.58.2107¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.59.1520¿]\n¿¿¿property¿[pp_type: ∀ (i : I), f x ∈ F i¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.58.2152¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.59.1525¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.2169¿]¿, PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.59.1522¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.59.1524¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.58.2107¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.59.1522¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.59.1527¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.2169¿]¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: x ∈ ⋂ (i : I), f⁻¹⟮F i⟯¿]: METAVAR¿[name: _mlocal._fresh.58.2155¿]¿= PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.58.2107¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.59.1520¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.59.1525¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.59.1520¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.59.1525¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.2176¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.59.1520¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.59.1524¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.59.1522¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.59.1527¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.2176¿]¿)¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.58.2079¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.59.1520¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.59.1525¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.59.1520¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.59.1525¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.2186¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.59.1520¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.59.1524¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.59.1522¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.59.1527¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.2186¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.59.1520¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.59.1524¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.59.1522¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.59.1525¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.59.1522¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.59.1525¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.2196¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.59.1522¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.59.1527¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.58.2196¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : ∀ (i : I), f x ∈ F i\n⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 462: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : ∀ (i : I), f x ∈ F i
⊢ x ∈ ⋂ (i : I), f⁻¹⟮F i⟯
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.59.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.59.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.58.2107'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': '∀ (i : I), f x ∈ F i', 'name': 'H2', 'identifier': '0._fresh.58.2152'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2169', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.59.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.58.2107'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.59.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2169', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'x ∈ ⋂ (i : I), f⁻¹⟮F i⟯', 'name': '_mlocal._fresh.58.2155'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.58.2107'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2176', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.59.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.59.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2176', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.58.2079'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2186', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.59.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.59.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2186', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.59.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2196', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.59.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2196', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.59.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2169', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2176', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.59.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.59.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2176', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.59.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2169', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2176', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.59.1524'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.59.1520'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.59.1527'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.59.1522'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.58.2176', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.59.1525'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     deaduction.dui.widgets.exercise_widgets: Code sent to Lean: `[ rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles, trace "EFFECTIVE CODE 13 : rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles"] <|> `[ rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles, trace "EFFECTIVE CODE 13 : rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles"] <|> `[ simp_rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles, trace "EFFECTIVE CODE 13 : simp_rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles"] <|> `[ simp_rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles, trace "EFFECTIVE CODE 13 : simp_rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles"],
DEBUG     ServerInterface: Updating, checking errors from line 460, and context at line 461
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\n`[ rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles, trace \"EFFECTIVE CODE 13 : rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles\"] <|> `[ rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles, trace \"EFFECTIVE CODE 13 : rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles\"] <|> `[ simp_rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles, trace \"EFFECTIVE CODE 13 : simp_rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles\"] <|> `[ simp_rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles, trace \"EFFECTIVE CODE 13 : simp_rw <- theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles\"],\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 26, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":26}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":460,"severity":"information","text":"EFFECTIVE CODE 13 : rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.60.3108¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.60.3110¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.60.3112¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.60.3108¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.60.3110¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.60.3113¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.60.3115¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.60.3113¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.60.3110¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.61.1723¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.60.3108¿]\n¿¿¿property¿[pp_type: ∀ (i : I), f x ∈ F i¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.61.1768¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.60.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.61.1800¿]¿, PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.60.3110¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.60.3112¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.61.1723¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.60.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.60.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.61.1800¿]¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)¿]: METAVAR¿[name: _mlocal._fresh.61.1782¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.60.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.61.1808¿]¿, PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.61.1723¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.60.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.60.3112¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.60.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.60.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.61.1808¿]¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.61.1695¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.60.3108¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.60.3113¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.60.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.60.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.61.1815¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.60.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.60.3112¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.60.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.60.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.61.1815¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.60.3108¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.60.3112¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.60.3110¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.60.3113¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.60.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.60.3113¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.61.1826¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.60.3110¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.60.3115¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.61.1826¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : ∀ (i : I), f x ∈ F i\n⊢ ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got EFFECTIVE CODE 13 : rw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles
 at line 460
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 463: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : ∀ (i : I), f x ∈ F i
⊢ ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.60.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.60.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.61.1723'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': '∀ (i : I), f x ∈ F i', 'name': 'H2', 'identifier': '0._fresh.61.1768'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1800', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.60.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.61.1723'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.60.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1800', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '∀ (i : I), x ∈ (f⁻¹⟮F i⟯)', 'name': '_mlocal._fresh.61.1782'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1808', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.61.1723'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.60.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.60.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1808', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.61.1695'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1815', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.60.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.60.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1815', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.60.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1826', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.60.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1826', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.60.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1800', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.60.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.60.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1808', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), utf8, 0
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.60.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1800', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.60.3112'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.60.3108'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.60.3115'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.60.3110'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.61.1808', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.60.3113'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), utf8, 0
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     deaduction.dui.widgets.exercise_widgets: Code sent to Lean: `[ rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque, trace "EFFECTIVE CODE 14 : rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque"] <|> `[ rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque, trace "EFFECTIVE CODE 14 : rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque"] <|> `[ simp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque, trace "EFFECTIVE CODE 14 : simp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque"] <|> `[ simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque, trace "EFFECTIVE CODE 14 : simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque"],
DEBUG     ServerInterface: Updating, checking errors from line 461, and context at line 462
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles,\n`[ rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque, trace \"EFFECTIVE CODE 14 : rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque\"] <|> `[ rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque, trace \"EFFECTIVE CODE 14 : rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque\"] <|> `[ simp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque, trace \"EFFECTIVE CODE 14 : simp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque\"] <|> `[ simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque, trace \"EFFECTIVE CODE 14 : simp_rw <- theorie_des_ensembles.applications_I.definitions.definition.image_reciproque\"],\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 27, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":27}
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","end_pos_col":0,"end_pos_line":465,"file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":445},{"desc":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","end_pos_col":0,"end_pos_line":465,"file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":445},{"desc":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","end_pos_col":0,"end_pos_line":465,"file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":445}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"information","text":"EFFECTIVE CODE 14 : simp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.62.3505¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.62.3507¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.62.3509¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.62.3505¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.62.3507¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.62.3510¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.62.3512¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.62.3510¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.62.3507¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.63.1781¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.62.3505¿]\n¿¿¿property¿[pp_type: ∀ (i : I), f x ∈ F i¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.63.1826¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.62.3510¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.63.2117¿]¿, PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.62.3507¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.62.3509¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.63.1781¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.62.3507¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.62.3512¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.63.2117¿]¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: ∀ (i : I), f x ∈ F i¿]: METAVAR¿[name: _mlocal._fresh.63.2095¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.62.3510¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.63.2125¿]¿, PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.62.3507¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.62.3509¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.63.1781¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.62.3507¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.62.3512¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.63.2125¿]¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.63.1753¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.62.3505¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.62.3510¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.62.3505¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.62.3510¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.63.2132¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.62.3505¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.62.3509¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.62.3507¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.62.3512¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.63.2132¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.62.3505¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.62.3509¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.62.3507¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.62.3510¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.62.3507¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.62.3510¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.63.2144¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.62.3507¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.62.3512¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.63.2144¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":464,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : ∀ (i : I), f x ∈ F i\n⊢ ∀ (i : I), f x ∈ F i\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got EFFECTIVE CODE 14 : simp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque
 at line 461
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 464: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : ∀ (i : I), f x ∈ F i
⊢ ∀ (i : I), f x ∈ F i
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.62.3509'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.62.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.63.1781'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': '∀ (i : I), f x ∈ F i', 'name': 'H2', 'identifier': '0._fresh.63.1826'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2117', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.62.3509'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.63.1781'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.62.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2117', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '∀ (i : I), f x ∈ F i', 'name': '_mlocal._fresh.63.2095'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2125', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.62.3509'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.63.1781'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.62.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2125', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.63.1753'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2132', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.62.3509'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.62.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2132', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.62.3509'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.62.3505'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2144', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.62.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2144', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.62.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2117', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.62.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2125', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.62.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2117', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.62.3512'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.62.3507'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.63.2125', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.62.3510'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 460, and context at line 461
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 28, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":28}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":461,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.64.1917¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.64.1919¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.64.1921¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.64.1917¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.64.1919¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.64.1922¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.64.1924¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.64.1922¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.64.1919¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.65.1079¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.64.1917¿]\n¿¿¿property¿[pp_type: ∀ (i : I), f x ∈ F i¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.65.1124¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.64.1922¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.65.1156¿]¿, PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.64.1919¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.64.1921¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.65.1079¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.64.1919¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.64.1924¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.65.1156¿]¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)¿]: METAVAR¿[name: _mlocal._fresh.65.1138¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.64.1922¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.65.1164¿]¿, PROP_BELONGS¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.65.1079¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.64.1917¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.64.1921¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.64.1919¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.64.1924¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.65.1164¿]¿)¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.65.1051¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.64.1917¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.64.1922¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.64.1917¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.64.1922¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.65.1171¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.64.1917¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.64.1921¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.64.1919¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.64.1924¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.65.1171¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.64.1917¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.64.1921¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.64.1919¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.64.1922¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.64.1919¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.64.1922¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.65.1182¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.64.1919¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.64.1924¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.65.1182¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : ∀ (i : I), f x ∈ F i\n⊢ ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 463: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : ∀ (i : I), f x ∈ F i
⊢ ∀ (i : I), x ∈ (f⁻¹⟮F i⟯)
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.64.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.64.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.65.1079'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': '∀ (i : I), f x ∈ F i', 'name': 'H2', 'identifier': '0._fresh.65.1124'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1156', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.64.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.65.1079'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.64.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1156', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '∀ (i : I), x ∈ (f⁻¹⟮F i⟯)', 'name': '_mlocal._fresh.65.1138'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1164', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.65.1079'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.64.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.64.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1164', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.65.1051'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1171', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.64.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.64.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1171', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.64.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1182', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.64.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1182', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.64.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1156', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.64.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.64.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1164', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), utf8, 0
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.64.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1156', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.64.1921'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.64.1917'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.64.1924'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.64.1919'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.65.1164', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.64.1922'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), utf8, 0
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     ServerInterface: Updating, checking errors from line 461, and context at line 462
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles,\nsimp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 29, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":29}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":462,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.66.2314¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.66.2316¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.66.2318¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.66.2314¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.66.2316¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.66.2319¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.66.2321¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.66.2319¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.66.2316¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.67.1139¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.66.2314¿]\n¿¿¿property¿[pp_type: ∀ (i : I), f x ∈ F i¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.67.1184¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.66.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.67.1465¿]¿, PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.66.2316¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.66.2318¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.67.1139¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.66.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.66.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.67.1465¿]¿)¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: ∀ (i : I), f x ∈ F i¿]: METAVAR¿[name: _mlocal._fresh.67.1443¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.66.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.67.1473¿]¿, PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.66.2316¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.66.2318¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.67.1139¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.66.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.66.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.67.1473¿]¿)¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.67.1111¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.66.2314¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.66.2319¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.66.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.66.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.67.1480¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.66.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.66.2318¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.66.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.66.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.67.1480¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.66.2314¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.66.2318¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.66.2316¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.66.2319¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.66.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.66.2319¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.67.1492¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.66.2316¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.66.2321¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.67.1492¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":464,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : ∀ (i : I), f x ∈ F i\n⊢ ∀ (i : I), f x ∈ F i\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 464: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : ∀ (i : I), f x ∈ F i
⊢ ∀ (i : I), f x ∈ F i
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.66.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.66.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.67.1139'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': '∀ (i : I), f x ∈ F i', 'name': 'H2', 'identifier': '0._fresh.67.1184'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1465', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.66.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.67.1139'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.66.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1465', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '∀ (i : I), f x ∈ F i', 'name': '_mlocal._fresh.67.1443'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1473', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.66.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.67.1139'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.66.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1473', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.67.1111'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1480', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.66.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.66.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1480', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.66.2318'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.66.2314'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1492', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.66.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1492', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.66.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1465', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.66.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1473', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.66.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1465', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.66.2321'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.66.2316'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.67.1473', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.66.2319'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
INFO      deaduction.dui.widgets.exercise_widgets: Calling action ∀
DEBUG     deaduction.dui.widgets.exercise_widgets: Code sent to lean: intro i
DEBUG     ServerInterface: Updating, checking errors from line 462, and context at line 463
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles,\nsimp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque,\nintro i,\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 30, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":30}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.68.2467¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.68.2469¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.68.2471¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.68.2467¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.68.2469¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.68.2472¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.68.2474¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.68.2472¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.68.2469¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.69.1197¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.68.2467¿]\n¿¿¿property¿[pp_type: ∀ (i : I), f x ∈ F i¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.69.1242¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.68.2472¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.69.1525¿]¿, PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.68.2469¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.68.2471¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.69.1197¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.68.2469¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.68.2474¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.69.1525¿]¿)¿)¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: i¿/ identifier: 0._fresh.69.1509¿]¿= LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.68.2472¿]\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":464,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: f x ∈ F i¿]: METAVAR¿[name: _mlocal._fresh.69.1510¿]¿= PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.68.2469¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.68.2471¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.69.1197¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.68.2469¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.68.2474¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: 0._fresh.69.1509¿]¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.69.1169¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.68.2467¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.68.2472¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.68.2467¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.68.2472¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.69.1534¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.68.2467¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.68.2471¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.68.2469¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.68.2474¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.69.1534¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.68.2467¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.68.2471¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.68.2469¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.68.2472¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.68.2469¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.68.2472¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.69.1546¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.68.2469¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.68.2474¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.69.1546¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":465,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : ∀ (i : I), f x ∈ F i,\ni : I\n⊢ f x ∈ F i\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 465: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : ∀ (i : I), f x ∈ F i,
i : I
⊢ f x ∈ F i
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.68.2471'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.68.2474'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.69.1197'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': '∀ (i : I), f x ∈ F i', 'name': 'H2', 'identifier': '0._fresh.69.1242'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.69.1525', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.68.2471'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.69.1197'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.68.2474'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.69.1525', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '0._fresh.69.1509'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'f x ∈ F i', 'name': '_mlocal._fresh.69.1510'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.68.2471'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.69.1197'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.68.2474'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '0._fresh.69.1509'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.69.1169'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.69.1534', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.68.2471'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.68.2474'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.69.1534', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.68.2471'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.68.2467'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.69.1546', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.68.2474'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.69.1546', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.68.2474'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.69.1525', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.68.2474'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '0._fresh.69.1509'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.68.2474'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.69.1525', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.68.2474'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.68.2469'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '0._fresh.69.1509'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.68.2472'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
INFO      deaduction.dui.widgets.exercise_widgets: Calling action ∀
INFO      deaduction.dui.widgets.exercise_widgets: Calling action ⊩
INFO      deaduction.dui.widgets.exercise_widgets: Calling action ⊩
INFO      logic          : QUANT_∀
DEBUG     deaduction.dui.widgets.exercise_widgets: Code sent to lean: `[ rw <- i at H2, trace "EFFECTIVE CODE 16 : rw <- i at H2"] <|> `[ rw i at H2, trace "EFFECTIVE CODE 16 : rw i at H2"] <|> `[ rw <- H2 at i, trace "EFFECTIVE CODE 16 : rw <- H2 at i"] <|> `[ rw H2 at i, trace "EFFECTIVE CODE 16 : rw H2 at i"] <|> `[ have H3 := H2 i, trace "EFFECTIVE CODE 16 : have H3 := H2 i"] <|> `[ have H3 := H2 _ i, trace "EFFECTIVE CODE 16 : have H3 := H2 _ i"] <|> `[ have H3 := H2 _ _ i, trace "EFFECTIVE CODE 16 : have H3 := H2 _ _ i"] <|> `[ have H3 := H2 _ _ _ i, trace "EFFECTIVE CODE 16 : have H3 := H2 _ _ _ i"] <|> `[ have H3 := H2 _ _ _ _ i, trace "EFFECTIVE CODE 16 : have H3 := H2 _ _ _ _ i"] <|> `[ have H3 := @H2 i, trace "EFFECTIVE CODE 16 : have H3 := @H2 i"] <|> `[ have H3 := @H2 _ i, trace "EFFECTIVE CODE 16 : have H3 := @H2 _ i"] <|> `[ have H3 := @H2 _ _ i, trace "EFFECTIVE CODE 16 : have H3 := @H2 _ _ i"] <|> `[ have H3 := @H2 _ _ _ i, trace "EFFECTIVE CODE 16 : have H3 := @H2 _ _ _ i"] <|> `[ have H3 := @H2 _ _ _ _ i, trace "EFFECTIVE CODE 16 : have H3 := @H2 _ _ _ _ i"],
DEBUG     ServerInterface: Updating, checking errors from line 463, and context at line 464
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles,\nsimp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque,\nintro i,\n`[ rw <- i at H2, trace \"EFFECTIVE CODE 16 : rw <- i at H2\"] <|> `[ rw i at H2, trace \"EFFECTIVE CODE 16 : rw i at H2\"] <|> `[ rw <- H2 at i, trace \"EFFECTIVE CODE 16 : rw <- H2 at i\"] <|> `[ rw H2 at i, trace \"EFFECTIVE CODE 16 : rw H2 at i\"] <|> `[ have H3 := H2 i, trace \"EFFECTIVE CODE 16 : have H3 := H2 i\"] <|> `[ have H3 := H2 _ i, trace \"EFFECTIVE CODE 16 : have H3 := H2 _ i\"] <|> `[ have H3 := H2 _ _ i, trace \"EFFECTIVE CODE 16 : have H3 := H2 _ _ i\"] <|> `[ have H3 := H2 _ _ _ i, trace \"EFFECTIVE CODE 16 : have H3 := H2 _ _ _ i\"] <|> `[ have H3 := H2 _ _ _ _ i, trace \"EFFECTIVE CODE 16 : have H3 := H2 _ _ _ _ i\"] <|> `[ have H3 := @H2 i, trace \"EFFECTIVE CODE 16 : have H3 := @H2 i\"] <|> `[ have H3 := @H2 _ i, trace \"EFFECTIVE CODE 16 : have H3 := @H2 _ i\"] <|> `[ have H3 := @H2 _ _ i, trace \"EFFECTIVE CODE 16 : have H3 := @H2 _ _ i\"] <|> `[ have H3 := @H2 _ _ _ i, trace \"EFFECTIVE CODE 16 : have H3 := @H2 _ _ _ i\"] <|> `[ have H3 := @H2 _ _ _ _ i, trace \"EFFECTIVE CODE 16 : have H3 := @H2 _ _ _ _ i\"],\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 31, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":31}
DEBUG     lean           : Rx: {"is_running":true,"response":"current_tasks","tasks":[{"desc":"parsing at line 445","end_pos_col":11,"end_pos_line":470,"file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":445}]}
DEBUG     lean           : Updating lean running state : True
INFO      ServerInterface: New lean state: True
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"}],"response":"all_messages"}
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":463,"severity":"information","text":"EFFECTIVE CODE 16 : have H3 := H2 i\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":464,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.70.15885¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.70.15889¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.70.15885¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.70.15890¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.70.15892¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.70.15890¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.71.3180¿]¿= LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.70.15885¿]\n¿¿¿property¿[pp_type: ∀ (i : I), f x ∈ F i¿]: LOCAL_CONSTANT¿[name: H2¿/ identifier: 0._fresh.71.3225¿]¿= QUANT_∀¿[type: PROP¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.70.15890¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.71.3515¿]¿, PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.70.15889¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.71.3180¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.70.15892¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.71.3515¿]¿)¿)¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: i¿/ identifier: 0._fresh.71.3492¿]¿= LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.70.15890¿]\n¿¿¿property¿[pp_type: f x ∈ F i¿]: LOCAL_CONSTANT¿[name: H3¿/ identifier: 0._fresh.71.3499¿]¿= PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.70.15889¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.71.3180¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.70.15892¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: 0._fresh.71.3492¿]¿)¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":465,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: f x ∈ F i¿]: METAVAR¿[name: _mlocal._fresh.71.3500¿]¿= PROP_BELONGS¿[type: PROP¿]¿(APPLICATION¿[type: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.70.15889¿]¿, LOCAL_CONSTANT¿[name: x¿/ identifier: 0._fresh.71.3180¿]¿)¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.70.15892¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: 0._fresh.71.3492¿]¿)¿)\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.71.3152¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.70.15885¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.70.15890¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.70.15885¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.70.15890¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.71.3526¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.70.15885¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.70.15889¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.70.15892¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.71.3526¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.70.15885¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.70.15889¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.70.15890¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.70.15890¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.71.3538¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.70.15887¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.70.15892¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.71.3538¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":466,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\n2 goals\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y,\nx : X,\nH2 : ∀ (i : I), f x ∈ F i,\ni : I,\nH3 : f x ∈ F i\n⊢ f x ∈ F i\n\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got EFFECTIVE CODE 16 : have H3 := H2 i
 at line 463
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 466: tactic failed, there are unsolved goals
state:
2 goals
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y,
x : X,
H2 : ∀ (i : I), f x ∈ F i,
i : I,
H3 : f x ∈ F i
⊢ f x ∈ F i
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.70.15889'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.71.3180'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': '∀ (i : I), f x ∈ F i', 'name': 'H2', 'identifier': '0._fresh.71.3225'}, math_type=MathObject(node='QUANT_∀', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.71.3515', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.70.15889'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.71.3180'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.71.3515', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '0._fresh.71.3492'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'pp_type': 'f x ∈ F i', 'name': 'H3', 'identifier': '0._fresh.71.3499'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.70.15889'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.71.3180'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '0._fresh.71.3492'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': 'f x ∈ F i', 'name': '_mlocal._fresh.71.3500'}, math_type=MathObject(node='PROP_BELONGS', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='APPLICATION', info={}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.70.15889'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'x', 'identifier': '0._fresh.71.3180'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '0._fresh.71.3492'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.71.3152'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.71.3526', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.70.15889'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.71.3526', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.70.15889'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.70.15885'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.71.3538', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.71.3538', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°1 / 2
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.71.3515', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '0._fresh.71.3492'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '0._fresh.71.3492'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.71.3515', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 0
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '0._fresh.71.3492'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.70.15892'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.70.15887'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '0._fresh.71.3492'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.70.15890'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])]), utf8, 1
INFO      deaduction.dui.widgets.exercise_widgets: Calling action CQFD
DEBUG     deaduction.dui.widgets.exercise_widgets: Code sent to lean: `[ assumption, trace "EFFECTIVE CODE 17 : assumption"] <|> `[ contradiction, trace "EFFECTIVE CODE 17 : contradiction"],
DEBUG     ServerInterface: Updating, checking errors from line 464, and context at line 465
DEBUG     lean           : Tx : {"file_name": "theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque", "content": "-- import data.set\nimport tactic\n\n-- dEAduction imports\nimport structures2\nimport definitions\nimport notations_definitions\n\n-- General principles :\n-- Type should be defined as parameters, in order to be implicit everywhere\n-- other parameters are implicit in definitions, i.e. defined using '{}' (e.g. {A : set X} )\n-- but explicit everywhere else, i.e. defined using '()' (e.g. (A : set X) )\n-- each definition must be an iff statement (since it will be called with 'rw' or 'symp_rw')\n\n\n\nlocal attribute [instance] classical.prop_decidable\n\n---------------------------------------------\n-- global parameters = implicit variables --\n---------------------------------------------\nsection course\nparameters {X Y Z: Type}\n\nnotation [parsing_only] P ` and ` Q := P \u2227 Q\nnotation [parsing_only]  P ` or ` Q := P \u2228 Q\nnotation [parsing_only]  ` not ` P := \u00ac P\nnotation [parsing_only]  P ` implies ` Q := P \u2192 Q\nnotation [parsing_only]  P ` iff ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` in ` A := x \u2208 A\nnotation [parsing_only]  A ` cap ` B := A \u2229 B\nnotation [parsing_only]  A ` cup ` B := A \u222a B\nnotation [parsing_only]  A ` subset ` B := A \u2286 B\nnotation [parsing_only]  `emptyset` := \u2205\n\nnotation [parsing_only] P ` et ` Q := P \u2227 Q\nnotation [parsing_only]  P ` ou ` Q := P \u2228 Q\nnotation [parsing_only]  ` non ` P := \u00ac P\nnotation [parsing_only]  P ` implique ` Q := P \u2192 Q\nnotation [parsing_only]  P ` ssi ` Q := P \u2194 Q\n\nnotation [parsing_only]  x ` dans ` A := x \u2208 A\nnotation [parsing_only]  x ` appartient ` A := x \u2208 A\nnotation [parsing_only]  A ` inter ` B := A \u2229 B\nnotation [parsing_only]  A ` intersection ` B := A \u2229 B\nnotation [parsing_only]  A ` union ` B := A \u222a B\nnotation [parsing_only]  A ` inclus ` B := A \u2286 B\nnotation [parsing_only]  `vide` := \u2205\n\nnotation f `\u27ee` A `\u27ef` := f '' A\nnotation f `\u207b\u00b9\u27ee` A `\u27ef` := f  \u207b\u00b9' A\nnotation [parsing_only] f `inverse` A := f  \u207b\u00b9' A\nnotation g `\u2218` f := set.composition g f\n\nopen set\n\n------------------\n-- COURSE TITLE --\n------------------\nnamespace theorie_des_ensembles\n/- dEAduction\nPrettyName\n    Th\u00e9orie des ensembles\n-/\n\nnamespace generalites\n/- dEAduction\nPrettyName\n    G\u00e9n\u00e9ralit\u00e9s\n-/\n\n------------------------\n-- COURSE DEFINITIONS --\n------------------------\n--lemma definition.ssi {P Q : Prop} : (P \u2194 Q) \u2194 (P \u2192 Q) \u2227 (Q \u2192 P) :=\n--begin\n--    exact iff_def\n--end\nlemma definition.inclusion {A B : set X} : A \u2286 B \u2194 \u2200 {x:X}, x \u2208 A \u2192 x \u2208 B :=\nbegin\n    exact iff.rfl\nend\n\nlemma definition.egalite_deux_ensembles {A A' : set X} :\n(A = A') \u2194 ( \u2200 x, x \u2208 A \u2194 x \u2208 A' ) :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux ensembles\n-/\nbegin\n     exact set.ext_iff\nend\n\nlemma definition.ensemble_vide\n(A: set X) :\n(A = \u2205) \u2194 \u2200 x : X, x \u2209 A\n:=\nbegin\n    exact eq_empty_iff_forall_not_mem,\nend\n\nlemma theorem.double_inclusion (A A' : set X) :\n(A \u2286 A' \u2227 A' \u2286 A) \u2192 A = A' :=\n/- dEAduction\nPrettyName\n    Double inclusion\n-/\nbegin\n    exact set.subset.antisymm_iff.mpr\nend\n\nend generalites\n\n---------------\n-- SECTION 1 --\n---------------\nnamespace unions_et_intersections\n-- variables unions_et_intersections --\nvariables {A B C : set X}\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\n\nlemma definition.intersection_deux_ensembles {A B : set X} {x : X} :\nx \u2208 A \u2229 B \u2194 ( x \u2208 A \u2227 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Intersection de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.intersection_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Inter (\u03bb i, E i)) \u2194 (\u2200 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Intersection d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Inter\nend\n\nlemma definition.union_deux_ensembles  {A : set X} {B : set X} {x : X} :\nx \u2208 A \u222a B \u2194 ( x \u2208 A \u2228 x \u2208 B) :=\n/- dEAduction\nPrettyName\n    Union de deux ensembles\n-/\nbegin\n    exact iff.rfl\nend\n\nlemma definition.union_quelconque_ensembles {I : Type} {E : I \u2192 set X}  {x : X} :\n(x \u2208 set.Union (\u03bb i, E i)) \u2194 (\u2203 i:I, x \u2208 E i) :=\n/- dEAduction\nPrettyName\n    Union d'une famille quelconque d'ensembles\n-/\nbegin\n    exact set.mem_Union\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n\nlemma exercise.union_distributive_inter : A \u2229 (B \u222a C)  = (A \u2229 B) \u222a (A \u2229 C) :=\n/- dEAduction\nPrettyName\n    Intersection avec une union\nDescription\n    L'intersection est distributive par rapport \u00e0 l'union\nTools->Logic\n    $ALL\nTools->ProofTechniques\n    $ALL\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\nTools->Theorems\n    double_inclusion\nExpectedVarsNumber\n    X=3, A=1, B=1\n-/\nbegin\n    sorry\nend\n\n-- NB: 'ExpectedVarsNumber' is not implemented yet\n-- planned to be used for naming variables\n\n\nlemma exercise.inter_distributive_union : A \u222a (B \u2229 C)  = (A \u222a B) \u2229 (A \u222a C) :=\n/- dEAduction\nPrettyName\n    Union avec une intersection\nDescription\n    L'union est distributive par rapport \u00e0 l'intersection\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\n\nend exercices\n\nend unions_et_intersections\n\n\n---------------\n-- SECTION 2 --\n---------------\nnamespace complementaire\n-- variables complementaire --\nvariables  {A B : set X}\nvariables {I : Type} {E F : I \u2192 set X}\n-- notation `\u2201`A := set.compl A\n\n-----------------\n-- DEFINITIONS --\n-----------------\nlemma definition.complement {A : set X} {x : X} : x \u2208 set.compl A \u2194 x \u2209 A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire\n-/\nbegin\n    finish\nend\n\n--lemma definition.difference_d_ensembles {A B : set X} {x : X} : x \u2208 B \\ A \u2194 (x \u2208 B \u2227 x \u2209 A) :=\n-- iff.rfl\n\n\n---------------\n-- EXERCICES --\n---------------\nlemma exercise.complement_complement : (set.compl (set.compl A)) = A :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire du compl\u00e9mentaire\nDescription\n    Tout ensemble est \u00e9gal au compl\u00e9mentaire de son compl\u00e9mentaire\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_deux :\nset.compl (A \u222a B) = (set.compl A) \u2229 (set.compl B) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union I\nDescription\n    Le compl\u00e9mentaire de l'union de deux ensembles \u00e9gale l'intersection des compl\u00e9mentaires\nTools->Definitions\n    $UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles\n-/\nbegin\n    sorry\nend\n\nlemma exercise.complement_union_quelconque :\nset.compl (set.Union (\u03bb i, E i)) = set.Inter (\u03bb i, set.compl (E i)) :=\n/- dEAduction\nPrettyName\n    Compl\u00e9mentaire d'union II\nDescription\n    Le compl\u00e9mentaire d'une r\u00e9union quelconque \u00e9gale l'intersection des compl\u00e9mentaires\n-/\nbegin\n    sorry\nend\n\n\nlemma exercise.inclusion_complement_I :\nA \u2286 B \u2192 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, implication\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\nlemma exercise.inclusion_complement_II :\nA \u2286 B \u2194 set.compl B \u2286 set.compl A\n:=\n/- dEAduction\nPrettyName\n    Le passage au compl\u00e9mentaire renverse les inclusions, \u00e9quivalence\nDescription\n    Si A est inclus dans B, alors le compl\u00e9mentaire de A contient le compl\u00e9mentaire de B\n-/\nbegin\n    sorry\nend\n\n/- Autres : diff\u00e9rence-/\n\nend complementaire\n\n\n\n-- Ajouter : 3. produit cart\u00e9sien, 4. relations ?\n-- comment d\u00e9finit-on un produit cart\u00e9sien d'ensembles ?\n\n\n\n---------------\n-- SECTION 3 --\n---------------\nnamespace applications_I\n/- dEAduction\nPrettyName\n    Applications et op\u00e9rations ensemblistes\n-/\n\n\n-- variables applications --\n\nvariables  {A A': set X}\nvariables {f: X \u2192 Y} {B B': set Y}\nvariables {I : Type} {E : I \u2192 set X} {F : I \u2192 set Y}\nvariables (g : Y \u2192 Z) (h : X \u2192 Z)\n\n-- a-t-on besoin de ceci ?\n-- lemma theorem.egalite_fonctions : f = f' \u2194 \u2200 x : X, f(x) = f'(x) :=\n--  function.funext_iff\n\n\n-----------------\n-- DEFINITIONS --\n-----------------\nnamespace definitions\n/- dEAduction\nPrettyName\n    D\u00e9finitions\n-/\nlemma definition.image_directe (y : Y) : y \u2208 f '' A \u2194 \u2203 x : X, x \u2208 A \u2227  f x = y :=\nbegin\n    sorry\nend\n\nlemma definition.image_reciproque (x:X) : x \u2208 f  \u207b\u00b9' B \u2194 f(x) \u2208 B :=\nbegin\n    sorry\nend\n\nlemma definition.composition :\n\u2200 x:X, composition g f x = g (f x)\n:=\nbegin\n    sorry,\nend\n\nlemma definition.egalite_fonctions (f' : X \u2192 Y) :\nf = f' \u2194 \u2200 x, f x = f' x :=\n/- dEAduction\nPrettyName\n    Egalit\u00e9 de deux fonctions\n-/\nbegin\n    exact function.funext_iff,\nend\n\n\nlemma definition.Identite (f\u2080: X \u2192 X) :\nf\u2080 = Identite \u2194 \u2200 x, f\u2080 x = x :=\n/- dEAduction\nPrettyName\n    Application identit\u00e9\n-/\nbegin\n    apply definition.egalite_fonctions,\nend\n\nend definitions\n\n---------------\n-- EXERCICES --\n---------------\nnamespace exercices\n/- dEAduction\nPrettyName\n    Exercices\n-/\nopen applications_I.definitions\n\nlemma exercise.image_de_reciproque : f '' (f \u207b\u00b9' B)  \u2286 B :=\n/- dEAduction\nPrettyName\n    Image de l'image r\u00e9ciproque\n-/\nbegin\n    sorry\nend\n\nlemma exercise.reciproque_de_image : A \u2286 f \u207b\u00b9' (f '' A) :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque de l'image\n-/\nbegin\n    sorry\nend\n\nlemma exercise.image_reciproque_inter :  f \u207b\u00b9'  (B\u2229B') = f \u207b\u00b9'  (B) \u2229 f \u207b\u00b9'  (B') :=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection de deux ensembles\n-/\nbegin\n    sorry\nend\n\nlemma  exercise.image_reciproque_union  : f \u207b\u00b9' (B \u222a B') = f \u207b\u00b9' B \u222a f \u207b\u00b9' B'\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une union de deux ensembles\n-/\nbegin\n    sorry\nend\n\n-- set_option pp.width 100\nlemma exercise.image_reciproque_inter_quelconque :\n(f \u207b\u00b9'  (set.Inter (\u03bb i, F i))) = set.Inter (\u03bb i, f \u207b\u00b9' (F i))\n:=\n/- dEAduction\nPrettyName\n    Image r\u00e9ciproque d'une intersection quelconque\n-/\nbegin\napply theorie_des_ensembles.generalites.theorem.double_inclusion,\nsplit,\nrw theorie_des_ensembles.generalites.definition.inclusion,\nintro x,\nintro H2,\nrw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles at H2,\nrw theorie_des_ensembles.unions_et_intersections.definitions.definition.intersection_quelconque_ensembles,\nsimp_rw theorie_des_ensembles.applications_I.definitions.definition.image_reciproque,\nintro i,\nhave H3 := H2 i,\n`[ assumption, trace \"EFFECTIVE CODE 17 : assumption\"] <|> `[ contradiction, trace \"EFFECTIVE CODE 17 : contradiction\"],\nhypo_analysis,\ntargets_analysis,\nend\nend exercices\nend applications_I\nend theorie_des_ensembles\nend course", "seq_num": 32, "command": "sync"}
DEBUG     lean           : Rx: {"message":"file invalidated","response":"ok","seq_num":32}
DEBUG     lean           : Rx: {"msgs":[{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":178,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.union_distributive_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":203,"severity":"warning","text":"declaration 'theorie_des_ensembles.unions_et_intersections.exercices.exercise.inter_distributive_union' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":250,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_complement' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":263,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_deux' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":277,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.complement_union_quelconque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":290,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_I' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":303,"severity":"warning","text":"declaration 'theorie_des_ensembles.complementaire.exercise.inclusion_complement_II' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":357,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_directe' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":362,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.image_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":367,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.definitions.definition.composition' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":407,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_de_reciproque' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":416,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.reciproque_de_image' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":425,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter' uses sorry"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":434,"severity":"warning","text":"declaration 'theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_union' uses sorry"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":464,"severity":"information","text":"EFFECTIVE CODE 17 : assumption\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":465,"severity":"information","text":"context:\n¿¿¿object: LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.72.3650¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.72.3652¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.72.3654¿]¿= FUNCTION¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.72.3650¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.72.3652¿]¿)\n¿¿¿object: LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.72.3655¿]¿= TYPE\n¿¿¿object: LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.72.3657¿]¿= SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.72.3655¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.72.3652¿]¿)\n"},{"caption":"trace output","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":466,"severity":"information","text":"targets:\n¿¿¿property¿[pp_type: (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)¿]: METAVAR¿[name: _mlocal._fresh.73.1643¿]¿= PROP_INCLUDED¿[type: PROP¿]¿(SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.72.3650¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.72.3655¿]¿, LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.72.3650¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.72.3655¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.73.2007¿]¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.72.3650¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.72.3654¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.72.3652¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.72.3657¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.73.2007¿]¿)¿)¿)¿)¿, SET_INVERSE¿[type: SET¿(LOCAL_CONSTANT¿[name: X¿/ identifier: 0._fresh.72.3650¿]¿)¿]¿(LOCAL_CONSTANT¿[name: f¿/ identifier: 0._fresh.72.3654¿]¿, SET_INTER+¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.72.3652¿]¿)¿]¿(LAMBDA¿[type: SET_FAMILY¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.72.3655¿]¿, LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.72.3652¿]¿)¿]¿(LOCAL_CONSTANT¿[name: I¿/ identifier: 0._fresh.72.3655¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.73.2019¿]¿, APPLICATION¿[type: SET¿(LOCAL_CONSTANT¿[name: Y¿/ identifier: 0._fresh.72.3652¿]¿)¿]¿(LOCAL_CONSTANT¿[name: F¿/ identifier: 0._fresh.72.3657¿]¿, LOCAL_CONSTANT¿[name: i¿/ identifier: _fresh.73.2019¿]¿)¿)¿)¿)¿)\n"},{"caption":"","file_name":"theorie_des_ensembles.applications_I.exercices.exercise.image_reciproque_inter_quelconque","pos_col":0,"pos_line":467,"severity":"error","text":"tactic failed, there are unsolved goals\nstate:\nX Y : Type,\nf : X → Y,\nI : Type,\nF : I → set Y\n⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)"}],"response":"all_messages"}
INFO      ServerInterface: Got EFFECTIVE CODE 17 : assumption
 at line 464
INFO      ServerInterface: Got new context
INFO      ServerInterface: Got new targets
ERROR     ServerInterface: Lean error at line 467: tactic failed, there are unsolved goals
state:
X Y : Type,
f : X → Y,
I : Type,
F : I → set Y
⊢ (⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)
DEBUG     ServerInterface: Proof State received
DEBUG     ServerInterface: After request
INFO      deaduction.pylib.mathobj.proof_state: creating new ProofState from lean strings
INFO      deaduction.pylib.mathobj.proof_state: creating new Goal from lean strings
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.72.3650'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.72.3652'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.72.3654'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.72.3650'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.72.3652'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.72.3657'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.72.3652'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[])
DEBUG     deaduction.pylib.mathobj.lean_analysis_with_type: Creating global var MathObject MathObject(node='METAVAR', info={'pp_type': '(⋂ (i : I), f⁻¹⟮F i⟯) ⊆ (f⁻¹⟮(⋂ (i : I), F i)⟯)', 'name': '_mlocal._fresh.73.1643'}, math_type=MathObject(node='PROP_INCLUDED', info={}, math_type=MathObject(node='PROP', info={}, math_type='not provided', children=[]), children=[MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.72.3650'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.72.3650'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.73.2007', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.72.3650'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.72.3654'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.72.3650'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.72.3652'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.72.3652'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.72.3657'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.72.3652'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.73.2007', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])]), MathObject(node='SET_INVERSE', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.72.3650'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'f', 'identifier': '0._fresh.72.3654'}, math_type=MathObject(node='FUNCTION', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'X', 'identifier': '0._fresh.72.3650'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.72.3652'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='SET_INTER+', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.72.3652'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LAMBDA', info={}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.72.3652'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.73.2019', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[]), MathObject(node='APPLICATION', info={}, math_type=MathObject(node='SET', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.72.3652'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'F', 'identifier': '0._fresh.72.3657'}, math_type=MathObject(node='SET_FAMILY', info={}, math_type='not provided', children=[MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'Y', 'identifier': '0._fresh.72.3652'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[])]), children=[]), MathObject(node='LOCAL_CONSTANT', info={'name': 'i', 'identifier': '_fresh.73.2019', 'lean_name': 'i'}, math_type=MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), children=[])])])])])]), children=[])
INFO      deaduction.pylib.mathobj.proof_state: comparing and tagging old goal and new goal
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.dui.widgets.exercise_widgets: Goal n°2 / 2
INFO      deaduction.dui.widgets.exercise_widgets: Current goal solved!
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
INFO      deaduction.pylib.mathobj.proof_state: split objects and propositions of the context
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     deaduction.pylib.mathobj.display_math: display ∈ with MathObject(node='LOCAL_CONSTANT', info={'name': 'I', 'identifier': '0._fresh.72.3655'}, math_type=MathObject(node='TYPE', info={}, math_type='not provided', children=[]), children=[]), utf8, 1
DEBUG     lean           : Rx: {"is_running":false,"response":"current_tasks","tasks":[]}
DEBUG     lean           : Updating lean running state : False
INFO      ServerInterface: New lean state: False
--- Value(None)
