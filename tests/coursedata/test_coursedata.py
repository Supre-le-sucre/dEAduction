"""
# test_coursedata.py : test coursedata files #

Author(s)     : Frédéric Le Roux frederic.le-roux@imj-prg.fr
Maintainer(s) : Frédéric Le Roux frederic.le-roux@imj-prg.fr
Created       : 11 2020 (creation)
Repo          : https://github.com/dEAduction/dEAduction

Copyright (c) 2020 the d∃∀duction team

This file is part of d∃∀duction.

    d∃∀duction is free software: you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation, either version 3 of the License, or (at your option)
    any later version.

    d∃∀duction is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
    more details.

    You should have received a copy of the GNU General Public License along
    with dEAduction.  If not, see <https://www.gnu.org/licenses/>.
"""

from deaduction.pylib.coursedata.exercise_classes import (Exercise, Definition,
                                                          Theorem, Statement)
from deaduction.pylib.coursedata import Course, parser_course


def test_course_parser(course, file_content):
    """Test lean_course_grammar from parser_course.py"""
    course_tree = parser_course.lean_course_grammar.parse(file_content)
    visitor = parser_course.LeanCourseVisitor()
    course_history, course_metadata = visitor.visit(course_tree)
    print(f"course history:\n{course_history}")
    assert course_history == [('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'theorie_des_ensembles', 'pretty_name': 'Théorie des ensembles'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'generalites', 'pretty_name': 'Généralités'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.inclusion', 'lean_variables': '{A B : set X}', 'lean_core_statement': 'A ⊆ B ↔ ∀ {x:X}, x ∈ A → x ∈ B', 'PrettyName': 'Inclusion'}), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': 'Egalité de deux ensembles', 'lean_name': 'definition.egalite_deux_ensembles', 'lean_variables': "{A A' : set X}", 'lean_core_statement': "(A = A') ↔ ( ∀ x, x ∈ A ↔ x ∈ A' )"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.ensemble_vide', 'lean_variables': '(A: set X)', 'lean_core_statement': '(A = ∅) ↔ ∀ x : X, x ∉ A', 'PrettyName': 'Ensemble vide'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('theorem', {'PrettyName': 'Double inclusion', 'lean_name': 'theorem.double_inclusion', 'lean_variables': "(A A' : set X)", 'lean_core_statement': "(A ⊆ A' ∧ A' ⊆ A) → A = A'"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Transitivité de l'inclusion", 'lean_name': 'exercise.inclusion_transitive', 'lean_variables': '(A B C : set X)', 'lean_core_statement': '(A ⊆ B ∧ B ⊆ C) → A ⊆ C'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'generalites'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'unions_et_intersections', 'pretty_name': 'Unions et intersections'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'definitions', 'pretty_name': 'Définitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': 'Intersection de deux ensembles', 'lean_name': 'definition.intersection_deux_ensembles', 'lean_variables': '{A B : set X} {x : X}', 'lean_core_statement': 'x ∈ A ∩ B ↔ ( x ∈ A ∧ x ∈ B)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': "Intersection d'une famille quelconque d'ensembles", 'lean_name': 'definition.intersection_quelconque_ensembles', 'lean_variables': '{I : Type} {E : I → set X}  {x : X}', 'lean_core_statement': '(x ∈ set.Inter (λ i, E i)) ↔ (∀ i:I, x ∈ E i)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': 'Union de deux ensembles', 'lean_name': 'definition.union_deux_ensembles', 'lean_variables': '{A : set X} {B : set X} {x : X}', 'lean_core_statement': 'x ∈ A ∪ B ↔ ( x ∈ A ∨ x ∈ B)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': "Union d'une famille quelconque d'ensembles", 'lean_name': 'definition.union_quelconque_ensembles', 'lean_variables': '{I : Type} {E : I → set X}  {x : X}', 'lean_core_statement': '(x ∈ set.Union (λ i, E i)) ↔ (∃ i:I, x ∈ E i)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'definitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'exercices', 'pretty_name': 'Exercices'}), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Un ensemble contient son intersection avec un autre', 'lean_name': 'exercise.intersection_inclus_ensemble', 'lean_variables': '', 'lean_core_statement': 'A ∩ B ⊆ A'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Intersection avec une union', 'Description': "L'intersection est distributive par rapport à l'union", 'Tools->Logic': '$ALL', 'Tools->ProofTechniques': '$ALL', 'Tools->Definitions': '$UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles', 'Tools->Theorems': 'double_inclusion', 'ExpectedVarsNumber': 'X=3, A=1, B=1', 'lean_name': 'exercise.union_distributive_inter', 'lean_variables': '', 'lean_core_statement': 'A ∩ (B ∪ C)  = (A ∩ B) ∪ (A ∩ C)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Union avec une intersection', 'Description': "L'union est distributive par rapport à l'intersection", 'Tools->Definitions': '$UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles', 'lean_name': 'exercise.inter_distributive_union', 'lean_variables': '', 'lean_core_statement': 'A ∪ (B ∩ C)  = (A ∪ B) ∩ (A ∪ C)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'exercices'}), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'unions_et_intersections'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'complementaire', 'pretty_name': 'Complementaire'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': 'Complémentaire', 'lean_name': 'definition.complement', 'lean_variables': '{A : set X} {x : X}', 'lean_core_statement': 'x ∈ set.compl A ↔ x ∉ A'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Complémentaire du complémentaire', 'Description': 'Tout ensemble est égal au complémentaire de son complémentaire', 'Tools->Definitions': '$UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles', 'lean_name': 'exercise.complement_complement', 'lean_variables': '', 'lean_core_statement': '(set.compl (set.compl A)) = A'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Complémentaire d'union I", 'Description': "Le complémentaire de l'union de deux ensembles égale l'intersection des complémentaires", 'Tools->Definitions': '$UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles', 'lean_name': 'exercise.complement_union_deux', 'lean_variables': '', 'lean_core_statement': 'set.compl (A ∪ B) = (set.compl A) ∩ (set.compl B)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Complémentaire d'union II", 'Description': "Le complémentaire d'une réunion quelconque égale l'intersection des complémentaires", 'lean_name': 'exercise.complement_union_quelconque', 'lean_variables': '', 'lean_core_statement': 'set.compl (set.Union (λ i, E i)) = set.Inter (λ i, set.compl (E i))'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Le passage au complémentaire renverse les inclusions, implication', 'Description': 'Si A est inclus dans B, alors le complémentaire de A contient le complémentaire de B', 'lean_name': 'exercise.inclusion_complement_I', 'lean_variables': '', 'lean_core_statement': 'A ⊆ B → set.compl B ⊆ set.compl A'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Le passage au complémentaire renverse les inclusions, équivalence', 'Description': 'Si A est inclus dans B, alors le complémentaire de A contient le complémentaire de B', 'lean_name': 'exercise.inclusion_complement_II', 'lean_variables': '', 'lean_core_statement': 'A ⊆ B ↔ set.compl B ⊆ set.compl A'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'complementaire'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'applications_I', 'pretty_name': 'Applications et opérations ensemblistes'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'definitions', 'pretty_name': 'Définitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.image_directe', 'lean_variables': '(y : Y)', 'lean_core_statement': "y ∈ f '' A ↔ ∃ x : X, x ∈ A ∧  f x = y", 'PrettyName': 'Image directe'}), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.image_reciproque', 'lean_variables': '(x:X)', 'lean_core_statement': "x ∈ f  ⁻¹' B ↔ f(x) ∈ B", 'PrettyName': 'Image reciproque'}), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.composition', 'lean_variables': '', 'lean_core_statement': '∀ x:X, composition g f x = g (f x)', 'PrettyName': 'Composition'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': 'Egalité de deux fonctions', 'lean_name': 'definition.egalite_fonctions', 'lean_variables': "(f' : X → Y)", 'lean_core_statement': "f = f' ↔ ∀ x, f x = f' x"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': 'Application identité', 'lean_name': 'definition.Identite', 'lean_variables': '(f₀: X → X)', 'lean_core_statement': 'f₀ = Identite ↔ ∀ x, f₀ x = x'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'definitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'exercices', 'pretty_name': 'Exercices'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Image de l'image réciproque", 'lean_name': 'exercise.image_de_reciproque', 'lean_variables': '', 'lean_core_statement': "f '' (f ⁻¹' B)  ⊆ B"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Image réciproque de l'image", 'lean_name': 'exercise.reciproque_de_image', 'lean_variables': '', 'lean_core_statement': "A ⊆ f ⁻¹' (f '' A)"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Image réciproque d'une intersection de deux ensembles", 'lean_name': 'exercise.image_reciproque_inter', 'lean_variables': '', 'lean_core_statement': "f ⁻¹'  (B∩B') = f ⁻¹'  (B) ∩ f ⁻¹'  (B')"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Image réciproque d'une union de deux ensembles", 'lean_name': 'exercise.image_reciproque_union', 'lean_variables': '', 'lean_core_statement': "f ⁻¹' (B ∪ B') = f ⁻¹' B ∪ f ⁻¹' B'"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Image réciproque d'une intersection quelconque", 'lean_name': 'exercise.image_reciproque_inter_quelconque', 'lean_variables': '', 'lean_core_statement': "(f ⁻¹'  (set.Inter (λ i, F i))) = set.Inter (λ i, f ⁻¹' (F i))"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Image réciproque d'une union quelconque", 'lean_name': 'exercise.image_reciproque_union_quelconque', 'lean_variables': '', 'lean_core_statement': "(f ⁻¹'  (set.Union (λ i, F i))) = set.Union (λ i, f ⁻¹' (F i))"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Image d'une intersection", 'lean_name': 'exercise.image_inter_inclus_inter_images', 'lean_variables': '', 'lean_core_statement': "f '' (A∩A') ⊆ f '' (A) ∩ f '' (A')"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Image réciproque du complémentaire, inclusion', 'lean_name': 'exercise.reciproque_complementaire_I', 'lean_variables': '', 'lean_core_statement': "f ⁻¹' (set.compl B) ⊆ set.compl (f ⁻¹' B)"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Image réciproque du complémentaire, égalité', 'lean_name': 'exercise.reciproque_complementaire_II', 'lean_variables': '', 'lean_core_statement': "f ⁻¹' (set.compl B) = set.compl (f ⁻¹' B)"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'exercices'}), ('end_of_line', None), ('close_namespace', {'name': 'applications_I'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'applications_II', 'pretty_name': 'Injections et surjections'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'definitions', 'pretty_name': 'Définitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': 'Application injective', 'lean_name': 'definition.injectivite', 'lean_variables': '', 'lean_core_statement': 'injective f ↔ ∀ x y : X, (f x = f y → x = y)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': 'Application surjective', 'lean_name': 'definition.surjectivite', 'lean_variables': '', 'lean_core_statement': 'surjective f ↔ ∀ y : Y, ∃ x : X, y = f x'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': '∃! : existence et unicité', 'lean_name': 'definition.existe_un_unique', 'lean_variables': '(P : X → Prop)', 'lean_core_statement': "(∃! (λx,  P x)) ↔  (∃ x : X, (P x ∧ (∀ x' : X, P x' → x' = x)))"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': 'Application bijective', 'lean_name': 'definition.bijectivite', 'lean_variables': '', 'lean_core_statement': 'bijective f ↔ ∀ y : Y, exists_unique (λ x, y = f x)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'definitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'exercices', 'pretty_name': 'Exercices'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Composition d'injections", 'lean_name': 'exercise.composition_injections', 'lean_variables': '(H1 : injective f) (H2 : injective g)', 'lean_core_statement': 'injective (composition g f)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Composition de surjections', 'lean_name': 'exercise.composition_surjections', 'lean_variables': '(H1 : surjective f) (H2 : surjective g)', 'lean_core_statement': 'surjective (composition g f)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Injective si composition injective', 'lean_name': 'exercise.injective_si_compo_injective', 'lean_variables': '(H1 : injective (composition g f))', 'lean_core_statement': 'injective f'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Surjective si composition surjective', 'lean_name': 'exercise.surjective_si_coompo_surjective', 'lean_variables': '(H1 : surjective (composition g f))', 'lean_core_statement': 'surjective g'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': '(x) Injectivité et inverse à gauche', 'lean_name': 'exercise.injective_ssi_inverse_gauche', 'lean_variables': '', 'lean_core_statement': '(injective f) ↔ ∃ F: Y → X, (composition F f) = Identite'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': '(*) Surjectivité et inverse à droite', 'lean_name': 'exercise.surjective_ssi_inverse_droite', 'lean_variables': '', 'lean_core_statement': '(surjective f) ↔ ∃ F: Y → X, (composition f F) = Identite'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': '(*) "Bijectif" équivaut à "injectif et surjectif"', 'lean_name': 'exercise.bijective_ssi_injective_et_surjective', 'lean_variables': '', 'lean_core_statement': '(bijective f) ↔ (injective f ∧ surjective f)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "(+) Bijectivité et existence d'une application réciproque", 'lean_name': 'exercise.bijective_ssi_inverse', 'lean_variables': '', 'lean_core_statement': '(bijective f) ↔ ∃ g : Y → X, composition g f = Identite ∧ composition g f  = Identite'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "(+) Unicité de la réciproque d'une application bijective", 'lean_name': 'exercise.unicite_inverse', 'lean_variables': '', 'lean_core_statement': '(bijective f) → exists_unique (λ g : Y → X, composition g f = Identite)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'exercices'}), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'applications_II'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'exercices_supplementaires', 'pretty_name': 'Exercices supplementaires'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Caractérisation de l'inclusion par l'intersection", 'lean_name': 'exercise.exercice_ensembles_1', 'lean_variables': '(A B : set X)', 'lean_core_statement': 'A ⊆ B ↔ A ∩ B = A'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Complémentaire d'une intersection", 'lean_name': 'exercise.complement_intersection_2', 'lean_variables': '(A B : set X)', 'lean_core_statement': 'set.compl (A ∩  B) = (set.compl A) ∪ (set.compl B)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Quand l'intersection égale l'union", 'lean_name': 'exercise.exercice_ensembles_3', 'lean_variables': '(A B : set X)', 'lean_core_statement': 'A ∩ B = A ∪ B → A = B'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Caractérisation par intersection avec A et son complémentaire, I', 'lean_name': 'exercise.exercice_ensembles_4a', 'lean_variables': '(A B C : set X)', 'lean_core_statement': 'A ∩ B = A ∩ C ∧ (set.compl A) ∩ B = (set.compl A) ∩ C → B ⊆ C'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Caractérisaton par intersection avec A et son complémentaire, II', 'lean_name': 'exercise.exercice_ensembles_4b', 'lean_variables': '(A B C : set X)', 'lean_core_statement': 'A ∩ B = A ∩ C ∧ (set.compl A) ∩ B = (set.compl A) ∩ C → B = C'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Même union et même intersection', 'lean_name': 'exercise.exercice_ensembles_5', 'lean_variables': '(A B C : set X)', 'lean_core_statement': 'A ∩ B = A ∩ C ∧ A ∪ B = A ∪ C → B = C'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'difference_et_difference_symetrique', 'pretty_name': 'Différence et différence symétrique'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'definitions', 'pretty_name': 'Définitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': 'Différence de deux ensembles', 'lean_name': 'definition.difference', 'lean_variables': '(A B : set X) (x : X)', 'lean_core_statement': 'x ∈ (A \\ B) ↔ x ∈ A ∧ x ∉ B'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'PrettyName': 'Différence symétrique de deux ensembles', 'lean_name': 'definition.difference_symetrique', 'lean_variables': '(A B : set X)', 'lean_core_statement': '(A Δ B) =  (A ∪ B) \\ (A ∩ B)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'definitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'exercices', 'pretty_name': 'Exercices'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Différence symétrique I', 'lean_name': 'exercise.difference_symetrique_1', 'lean_variables': '(A B : set X)', 'lean_core_statement': '(A Δ B) = (A \\ B) ∪ (B \\ A)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': '(*) Différence symétrique II', 'lean_name': 'exercise.difference_symetrique_2', 'lean_variables': '(A B : set X)', 'lean_core_statement': '(A Δ B) = (B Δ A)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': '(**) Différence symétrique III', 'lean_name': 'exercise.difference_symetrique_3', 'lean_variables': '(A B C : set X)', 'lean_core_statement': '((A Δ B) Δ C) = (A Δ (B Δ C))'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': '(+) Différence symétrique VI', 'lean_name': 'exercise.difference_symetrique_4', 'lean_variables': '', 'lean_core_statement': '∃! (λE : set X, ∀ A : set X, (A Δ E) = A)'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': '(+) Différence symétrique V', 'lean_name': 'exercise.difference_symetrique_5', 'lean_variables': '(A : set X)', 'lean_core_statement': "exists_unique (λA' : set X, (A Δ A') = set.univ)"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': '(+) Différence symétrique VI', 'lean_name': 'exercise.difference_symetrique_6', 'lean_variables': '(A B : set X)', 'lean_core_statement': '(A Δ B) = ∅ ↔ A = B'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'exercices'}), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'difference_et_difference_symetrique'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'applications', 'pretty_name': 'Applications'}), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': 'Image directe et inclusion', 'lean_name': 'exercise.exercice_applications_1', 'lean_variables': '(A B : set X)', 'lean_core_statement': "A ⊆ B → f '' A ⊆ f '' B"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': "Image d'une union", 'lean_name': 'exercise.exercice_applications_2', 'lean_variables': '(A B : set X)', 'lean_core_statement': "f '' (A ∪ B)  = f '' A ∪ f '' B"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': '(+) Factorisation I', 'lean_name': 'exercise.exercice_factorisation_I', 'lean_variables': '(g : Y → Z) (h: X → Z)', 'lean_core_statement': "(∃ f: X → Y, h = (composition g f)) ↔ h '' set.univ ⊆ g '' set.univ"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'PrettyName': '(+) Factorisation II', 'lean_name': 'exercise.exercice_factorisation_II', 'lean_variables': '(f : X → Y) (h: X → Z)', 'lean_core_statement': '(∃ g: Y → Z, h = (composition g f)) ↔ (∀ x y, (f x = f y → h x = h y))'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'applications'}), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'exercices_supplementaires'}), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'theorie_des_ensembles'}), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'course'})]


def test_statements_creation(file_content, statements):
    """Test Course.from_file_content method"""
    course = Course.from_file_content(file_content)
    assert len(statements) == len(course.statements)
    for (stpkl, st) in zip(statements, course.statements):
        assert stpkl.pretty_name == st.pretty_name
        if type(stpkl) == Exercise:
            assert stpkl.available_logic == st.available_logic