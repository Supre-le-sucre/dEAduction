"""
# test_coursedata.py : test coursedata files #

Author(s)     : Frédéric Le Roux frederic.le-roux@imj-prg.fr
Maintainer(s) : Frédéric Le Roux frederic.le-roux@imj-prg.fr
Created       : 11 2020 (creation)
Repo          : https://github.com/dEAduction/dEAduction

Copyright (c) 2020 the d∃∀duction team

This file is part of d∃∀duction.

    d∃∀duction is free software: you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation, either version 3 of the License, or (at your option)
    any later version.

    d∃∀duction is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
    more details.

    You should have received a copy of the GNU General Public License along
    with dEAduction.  If not, see <https://www.gnu.org/licenses/>.
"""

from deaduction.pylib.coursedata.exercise_classes import (Exercise, Definition,
                                                          Theorem, Statement)
from deaduction.pylib.coursedata import Course, parser_course


def test_course_parser(course, file_content):
    """Test lean_course_grammar from parser_course.py"""
    course_tree = parser_course.lean_course_grammar.parse(file_content)
    visitor = parser_course.LeanCourseVisitor()
    course_history, course_metadata = visitor.visit(course_tree)
    print(f"course history:\n{course_history}")
    # Replace by the result of previous line in case of new features:
    old_course_history = [('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'theorie_des_ensembles', 'pretty_name': 'Théorie des ensembles'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'generalites', 'pretty_name': 'Généralités'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.inclusion', 'lean_variables': '{A B : set X}', 'lean_core_statement': ' A ⊆ B ↔ ∀ {x:X}, x ∈ A → x ∈ B ', 'pretty_name': 'Inclusion'}), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': 'Egalité de deux ensembles', 'lean_name': 'definition.egalite_deux_ensembles', 'lean_variables': "{A A' : set X}", 'lean_core_statement': "\n(A = A') ↔ ( ∀ x, x ∈ A ↔ x ∈ A' ) "}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.ensemble_vide', 'lean_variables': '(A: set X)', 'lean_core_statement': '\n(A = ∅) ↔ ∀ x : X, x ∉ A\n', 'pretty_name': 'Ensemble vide'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('theorem', {'pretty_name': 'Double inclusion', 'lean_name': 'theorem.double_inclusion', 'lean_variables': "(A A' : set X)", 'lean_core_statement': "\n(A ⊆ A' ∧ A' ⊆ A) → A = A' "}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Transitivité de l'inclusion", 'available_logic': '$ALL -iff -exists -negate', 'available_proof': '$ALL -use_proof_methods -new_object', 'lean_name': 'exercise.inclusion_transitive', 'lean_variables': '(A B C : set X)', 'lean_core_statement': '\n(A ⊆ B ∧ B ⊆ C) → A ⊆ C\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'generalites'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'unions_et_intersections', 'pretty_name': 'Unions et intersections'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'definitions', 'pretty_name': 'Définitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': 'Intersection de deux ensembles', 'lean_name': 'definition.intersection_deux_ensembles', 'lean_variables': '{A B : set X} {x : X}', 'lean_core_statement': '\nx ∈ A ∩ B ↔ ( x ∈ A ∧ x ∈ B) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': "Intersection d'une famille quelconque d'ensembles", 'lean_name': 'definition.intersection_quelconque_ensembles', 'lean_variables': '{I : Type} {E : I → set X}  {x : X}', 'lean_core_statement': '\n(x ∈ set.Inter (λ i, E i)) ↔ (∀ i:I, x ∈ E i) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': 'Union de deux ensembles', 'lean_name': 'definition.union_deux_ensembles', 'lean_variables': '{A : set X} {B : set X} {x : X}', 'lean_core_statement': '\nx ∈ A ∪ B ↔ ( x ∈ A ∨ x ∈ B) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': "Union d'une famille quelconque d'ensembles", 'lean_name': 'definition.union_quelconque_ensembles', 'lean_variables': '{I : Type} {E : I → set X}  {x : X}', 'lean_core_statement': '\n(x ∈ set.Union (λ i, E i)) ↔ (∃ i:I, x ∈ E i) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'definitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'exercices', 'pretty_name': 'Exercices'}), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Un ensemble contient son intersection avec un autre', 'available_definitions': '$UNTIL_NOW -$FAMILY_STATEMENT', 'lean_name': 'exercise.intersection_inclus_ensemble', 'lean_variables': '', 'lean_core_statement': '\nA ∩ B ⊆ A\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Intersection avec une union', 'description': "L'intersection est distributive par rapport à l'union", 'available_definitions': '$UNTIL_NOW -$FAMILY_STATEMENT', 'expected_vars_number': 'X=3, A=1, B=1', 'lean_name': 'exercise.union_distributive_inter', 'lean_variables': '', 'lean_core_statement': ' A ∩ (B ∪ C)  = (A ∩ B) ∪ (A ∩ C) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Union avec une intersection', 'description': "L'union est distributive par rapport à l'intersection", 'available_definitions': '$UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles', 'lean_name': 'exercise.inter_distributive_union', 'lean_variables': '', 'lean_core_statement': ' A ∪ (B ∩ C)  = (A ∪ B) ∩ (A ∪ C) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'exercices'}), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'unions_et_intersections'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'complementaire', 'pretty_name': 'Complementaire'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': 'Complémentaire', 'lean_name': 'definition.complement', 'lean_variables': '{A : set X} {x : X}', 'lean_core_statement': ' x ∈ set.compl A ↔ x ∉ A '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Complémentaire du complémentaire', 'description': 'Tout ensemble est égal au complémentaire de son complémentaire', 'available_definitions': '$UNTIL_NOW -$FAMILY_STATEMENT', 'lean_name': 'exercise.complement_complement', 'lean_variables': '', 'lean_core_statement': ' (set.compl (set.compl A)) = A '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Complémentaire d'union I", 'description': "Le complémentaire de l'union de deux ensembles égale l'intersection des complémentaires", 'available_definitions': '$UNTIL_NOW -union_quelconque_ensembles -intersection_quelconque_ensembles', 'lean_name': 'exercise.complement_union_deux', 'lean_variables': '', 'lean_core_statement': '\nset.compl (A ∪ B) = (set.compl A) ∩ (set.compl B) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Complémentaire d'union II", 'description': "Le complémentaire d'une réunion quelconque égale l'intersection des complémentaires", 'lean_name': 'exercise.complement_union_quelconque', 'lean_variables': '', 'lean_core_statement': '\nset.compl (set.Union (λ i, E i)) = set.Inter (λ i, set.compl (E i)) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Le passage au complémentaire renverse les inclusions, implication', 'description': 'Si A est inclus dans B, alors le complémentaire de A contient le complémentaire de B', 'lean_name': 'exercise.inclusion_complement_I', 'lean_variables': '', 'lean_core_statement': '\nA ⊆ B → set.compl B ⊆ set.compl A\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Le passage au complémentaire renverse les inclusions, équivalence', 'description': 'Si A est inclus dans B, alors le complémentaire de A contient le complémentaire de B', 'lean_name': 'exercise.inclusion_complement_II', 'lean_variables': '', 'lean_core_statement': '\nA ⊆ B ↔ set.compl B ⊆ set.compl A\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'complementaire'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'applications_I', 'pretty_name': 'Applications et opérations ensemblistes'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'definitions', 'pretty_name': 'Définitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.image_directe', 'lean_variables': '(y : Y)', 'lean_core_statement': " y ∈ f '' A ↔ ∃ x : X, x ∈ A ∧  f x = y ", 'pretty_name': 'Image directe'}), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.image_reciproque', 'lean_variables': '(x:X)', 'lean_core_statement': " x ∈ f  ⁻¹' B ↔ f(x) ∈ B ", 'pretty_name': 'Image reciproque'}), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'lean_name': 'definition.composition', 'lean_variables': '', 'lean_core_statement': '\n∀ x:X, composition g f x = g (f x)\n', 'pretty_name': 'Composition'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': 'Egalité de deux fonctions', 'lean_name': 'definition.egalite_fonctions', 'lean_variables': "(f' : X → Y)", 'lean_core_statement': "\nf = f' ↔ ∀ x, f x = f' x "}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': 'Application identité', 'lean_name': 'definition.Identite', 'lean_variables': '(f₀: X → X)', 'lean_core_statement': '\nf₀ = Identite ↔ ∀ x, f₀ x = x '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'definitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'exercices', 'pretty_name': 'Exercices'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Image de l'image réciproque", 'lean_name': 'exercise.image_de_reciproque', 'lean_variables': '', 'lean_core_statement': " f '' (f ⁻¹' B)  ⊆ B "}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Image réciproque de l'image", 'lean_name': 'exercise.reciproque_de_image', 'lean_variables': '', 'lean_core_statement': " A ⊆ f ⁻¹' (f '' A) "}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Image réciproque d'une intersection de deux ensembles", 'lean_name': 'exercise.image_reciproque_inter', 'lean_variables': '', 'lean_core_statement': "  f ⁻¹'  (B∩B') = f ⁻¹'  (B) ∩ f ⁻¹'  (B') "}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Image réciproque d'une union de deux ensembles", 'lean_name': 'exercise.image_reciproque_union', 'lean_variables': '', 'lean_core_statement': " f ⁻¹' (B ∪ B') = f ⁻¹' B ∪ f ⁻¹' B'\n"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Image réciproque d'une intersection quelconque", 'lean_name': 'exercise.image_reciproque_inter_quelconque', 'lean_variables': '', 'lean_core_statement': "\n(f ⁻¹'  (set.Inter (λ i, F i))) = set.Inter (λ i, f ⁻¹' (F i))\n"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Image réciproque d'une union quelconque", 'lean_name': 'exercise.image_reciproque_union_quelconque', 'lean_variables': '', 'lean_core_statement': "\n(f ⁻¹'  (set.Union (λ i, F i))) = set.Union (λ i, f ⁻¹' (F i))\n"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Image d'une intersection", 'lean_name': 'exercise.image_inter_inclus_inter_images', 'lean_variables': '', 'lean_core_statement': "\nf '' (A∩A') ⊆ f '' (A) ∩ f '' (A')\n"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Image réciproque du complémentaire, inclusion', 'lean_name': 'exercise.reciproque_complementaire_I', 'lean_variables': '', 'lean_core_statement': "\nf ⁻¹' (set.compl B) ⊆ set.compl (f ⁻¹' B)\n"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Image réciproque du complémentaire, égalité', 'lean_name': 'exercise.reciproque_complementaire_II', 'lean_variables': '', 'lean_core_statement': "\nf ⁻¹' (set.compl B) = set.compl (f ⁻¹' B)\n"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'exercices'}), ('end_of_line', None), ('close_namespace', {'name': 'applications_I'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'applications_II', 'pretty_name': 'Injections et surjections'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'definitions', 'pretty_name': 'Définitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': 'Application injective', 'lean_name': 'definition.injectivite', 'lean_variables': '', 'lean_core_statement': '\ninjective f ↔ ∀ x y : X, (f x = f y → x = y)\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': 'Application surjective', 'lean_name': 'definition.surjectivite', 'lean_variables': '', 'lean_core_statement': '\nsurjective f ↔ ∀ y : Y, ∃ x : X, y = f x\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': '∃! : existence et unicité', 'lean_name': 'definition.existe_un_unique', 'lean_variables': '(P : X → Prop)', 'lean_core_statement': "\n(∃! (λx,  P x)) ↔  (∃ x : X, (P x ∧ (∀ x' : X, P x' → x' = x)))\n"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': 'Application bijective', 'lean_name': 'definition.bijectivite', 'lean_variables': '', 'lean_core_statement': '\nbijective f ↔ ∀ y : Y, exists_unique (λ x, y = f x)\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'definitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'exercices', 'pretty_name': 'Exercices'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Composition d'injections", 'lean_name': 'exercise.composition_injections', 'lean_variables': '(H1 : injective f) (H2 : injective g)', 'lean_core_statement': '\ninjective (composition g f)\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Composition de surjections', 'lean_name': 'exercise.composition_surjections', 'lean_variables': '(H1 : surjective f) (H2 : surjective g)', 'lean_core_statement': '\nsurjective (composition g f)\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Injective si composition injective', 'lean_name': 'exercise.injective_si_compo_injective', 'lean_variables': '(H1 : injective (composition g f))', 'lean_core_statement': '\ninjective f\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Surjective si composition surjective', 'lean_name': 'exercise.surjective_si_coompo_surjective', 'lean_variables': '(H1 : surjective (composition g f))', 'lean_core_statement': '\nsurjective g\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': '(x) Injectivité et inverse à gauche', 'lean_name': 'exercise.injective_ssi_inverse_gauche', 'lean_variables': '', 'lean_core_statement': ' (injective f) ↔\n∃ F: Y → X, (composition F f) = Identite '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': '(*) Surjectivité et inverse à droite', 'lean_name': 'exercise.surjective_ssi_inverse_droite', 'lean_variables': '', 'lean_core_statement': ' (surjective f) ↔\n∃ F: Y → X, (composition f F) = Identite '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': '(+) "Bijectif" équivaut à "injectif et surjectif"', 'lean_name': 'exercise.bijective_ssi_injective_et_surjective', 'lean_variables': '', 'lean_core_statement': '\n(bijective f) ↔ (injective f ∧ surjective f)\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "(+) Bijectivité et existence d'une application réciproque", 'lean_name': 'exercise.bijective_ssi_inverse', 'lean_variables': '', 'lean_core_statement': '\n(bijective f) ↔ ∃ g : Y → X,\ncomposition g f = Identite ∧ composition f g  = Identite\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "(+) Unicité de la réciproque d'une application bijective", 'lean_name': 'exercise.unicite_inverse', 'lean_variables': '', 'lean_core_statement': '\n(bijective f) → exists_unique (λ g : Y → X,\ncomposition g f = Identite)\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "(+) Théorème de Cantor : il n'y a pas de surjection d'un ensemble vers l'ensemble de ses parties", 'lean_name': 'exercise.Cantor', 'lean_variables': '', 'lean_core_statement': '\n∀ f : X → set X, ¬ surjective f\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'exercices'}), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'applications_II'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'exercices_supplementaires', 'pretty_name': 'Exercices supplementaires'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Caractérisation de l'inclusion par l'intersection", 'lean_name': 'exercise.exercice_ensembles_1', 'lean_variables': '(A B : set X)', 'lean_core_statement': '\nA ⊆ B ↔ A ∩ B = A\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Complémentaire d'une intersection", 'lean_name': 'exercise.complement_intersection_2', 'lean_variables': '(A B : set X)', 'lean_core_statement': '\nset.compl (A ∩  B) = (set.compl A) ∪ (set.compl B)\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Quand l'intersection égale l'union", 'lean_name': 'exercise.exercice_ensembles_3', 'lean_variables': '(A B : set X)', 'lean_core_statement': '\nA ∩ B = A ∪ B → A = B\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Caractérisation par intersection avec A et son complémentaire, I', 'lean_name': 'exercise.exercice_ensembles_4a', 'lean_variables': '(A B C : set X)', 'lean_core_statement': '\nA ∩ B = A ∩ C ∧ (set.compl A) ∩ B = (set.compl A) ∩ C → B ⊆ C\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Caractérisaton par intersection avec A et son complémentaire, II', 'lean_name': 'exercise.exercice_ensembles_4b', 'lean_variables': '(A B C : set X)', 'lean_core_statement': '\nA ∩ B = A ∩ C ∧ (set.compl A) ∩ B = (set.compl A) ∩ C → B = C\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Même union et même intersection', 'lean_name': 'exercise.exercice_ensembles_5', 'lean_variables': '(A B C : set X)', 'lean_core_statement': '\nA ∩ B = A ∩ C ∧ A ∪ B = A ∪ C → B = C\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'difference_et_difference_symetrique', 'pretty_name': 'Différence et différence symétrique'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'definitions', 'pretty_name': 'Définitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': 'Différence de deux ensembles', 'lean_name': 'definition.difference', 'lean_variables': '(A B : set X) (x : X)', 'lean_core_statement': '\nx ∈ (A \\ B) ↔ x ∈ A ∧ x ∉ B\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('definition', {'pretty_name': 'Différence symétrique de deux ensembles', 'lean_name': 'definition.difference_symetrique', 'lean_variables': '(A B : set X)', 'lean_core_statement': '\n(A Δ B) =  (A ∪ B) \\ (A ∩ B)\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'definitions'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'exercices', 'pretty_name': 'Exercices'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Différence symétrique I', 'lean_name': 'exercise.difference_symetrique_1', 'lean_variables': '(A B : set X)', 'lean_core_statement': '\n(A Δ B) = (A \\ B) ∪ (B \\ A)\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': '(*) Différence symétrique II', 'lean_name': 'exercise.difference_symetrique_2', 'lean_variables': '(A B : set X)', 'lean_core_statement': '\n(A Δ B) = (B Δ A)\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': '(**) Différence symétrique III', 'lean_name': 'exercise.difference_symetrique_3', 'lean_variables': '(A B C : set X)', 'lean_core_statement': '\n((A Δ B) Δ C) = (A Δ (B Δ C))\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': '(+) Différence symétrique VI', 'lean_name': 'exercise.difference_symetrique_4', 'lean_variables': '', 'lean_core_statement': '\n∃! (λE : set X, ∀ A : set X, (A Δ E) = A) '}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': '(+) Différence symétrique V', 'lean_name': 'exercise.difference_symetrique_5', 'lean_variables': '(A : set X)', 'lean_core_statement': "\nexists_unique (λA' : set X, (A Δ A') = set.univ)\n"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': '(+) Différence symétrique VI', 'lean_name': 'exercise.difference_symetrique_6', 'lean_variables': '(A B : set X)', 'lean_core_statement': '\n(A Δ B) = ∅ ↔ A = B\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'exercices'}), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'difference_et_difference_symetrique'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('open_namespace', {'name': 'applications', 'pretty_name': 'Applications'}), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': 'Image directe et inclusion', 'lean_name': 'exercise.exercice_applications_1', 'lean_variables': '(A B : set X)', 'lean_core_statement': "\nA ⊆ B → f '' A ⊆ f '' B\n"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': "Image d'une union", 'lean_name': 'exercise.exercice_applications_2', 'lean_variables': '(A B : set X)', 'lean_core_statement': "\nf '' (A ∪ B)  = f '' A ∪ f '' B\n"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': '(+) Factorisation I', 'lean_name': 'exercise.exercice_factorisation_I', 'lean_variables': '(g : Y → Z) (h: X → Z)', 'lean_core_statement': "\n(∃ f: X → Y, h = (composition g f)) ↔ h '' set.univ ⊆ g '' set.univ\n"}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('exercise', {'pretty_name': '(+) Factorisation II', 'lean_name': 'exercise.exercice_factorisation_II', 'lean_variables': '(f : X → Y) (h: X → Z)', 'lean_core_statement': '\n(∃ g: Y → Z, h = (composition g f)) ↔ (∀ x y, (f x = f y → h x = h y))\n'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('begin_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_proof', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'applications'}), ('end_of_line', None), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'exercices_supplementaires'}), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'theorie_des_ensembles'}), ('end_of_line', None), ('end_of_line', None), ('close_namespace', {'name': 'course'})]
    for old, new in zip (old_course_history, course_history):
        assert old == new


def test_statements_creation(file_content, statements):
    """Test Course.from_file_content method"""
    course = Course.from_file_content(file_content)
    assert len(statements) == len(course.statements)
    for st in course.statements:
        XXX = st.pretty_hierarchy(course.outline)
    for (stpkl, st) in zip(statements, course.statements):
        assert stpkl.pretty_name == st.pretty_name
        if type(stpkl) == Exercise:
            assert stpkl.available_logic == st.available_logic
            assert stpkl.available_logic == st.available_logic
